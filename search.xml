<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hygen</title>
    <url>/2022/08/31/Hygen/</url>
    <content><![CDATA[<h1 id="Hygen模板生成器"><a href="#Hygen模板生成器" class="headerlink" title="Hygen模板生成器"></a>Hygen模板生成器</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装：<code>npm i -g hygen </code></p>
<p>初始化hygen：<code>hygen init self</code></p>
<h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>生成模板：<code>hygen generator new component</code></p>
<p><img src="https://found-img-blog.oss-cn-hangzhou.aliyuncs.com/img/image-20220831210053873.png" alt="image-20220831210053873"></p>
<span id="more"></span>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>这里面的<code>.ejs.t</code>后缀文件就是一个个模板</p>
<ul>
<li><code>---</code>分割部分标识模板生成路径</li>
<li><code>&lt;%= name %&gt;</code>表示组件名字，也对应了下文指令</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="symbol">to:</span> src/components/&lt;%= name %&gt;/index.js</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> from <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> from <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Styled</span>&lt;%= name %&gt; from <span class="string">&#x27;./style&#x27;</span></span><br><span class="line"></span><br><span class="line">function &lt;%= name %&gt;(&#123;</span><br><span class="line">    children,</span><br><span class="line">  ...rest</span><br><span class="line">&#125;)&#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;<span class="title class_">Styled</span>&lt;%= name %&gt; &#123;...rest&#125;&gt;</span><br><span class="line">        children</span><br><span class="line">    &lt;/<span class="title class_">Styled</span>&lt;%= name %&gt;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%= name %&gt;.propTypes = &#123;</span><br><span class="line">    <span class="symbol">children:</span><span class="title class_">PropTypes</span>.any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &lt;%= name %&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>对于需要大写的模板可以使用内置的方法<ul>
<li><code>h.changeCase.lcFirst(name)</code></li>
</ul>
</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="symbol">to:</span> src/components/&lt;%= name %&gt;/&lt;%= h.changeCase.lcFirst(name) %&gt;.stories.js</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> from <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &lt;%= name %&gt; from <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    <span class="symbol">title:</span><span class="string">&quot;&lt;%= name %&gt;&quot;</span>,</span><br><span class="line">    <span class="symbol">component:</span>&lt;%= name %&gt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export const <span class="title class_">Default</span> = ()=&gt; &lt;&lt;%= name %&gt;&gt;默认&lt;&lt;%= name %&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>使用对应模板生成内容：</p>
<p><code>hygen component new Icon</code>    <em>这个Icon是自定义名字</em></p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>这个<strong>component</strong>叫做生成器，而<strong>new</strong>叫做action</p>
<p>一个hygen可以有多个生成器，一个生成器可以有多个action</p>
<blockquote>
<p>有趣的是上文中的<code>hygen generator new component</code>叫做生成器的生成器。</p>
<p>这个Icon对应上文中的<code>&lt;%= name %&gt;</code></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hygen</tag>
        <tag>模板</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Storybook</title>
    <url>/2021/06/20/Storybook/</url>
    <content><![CDATA[<h1 id="Storybook"><a href="#Storybook" class="headerlink" title="Storybook"></a>Storybook</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Storybook是帮助前端组件开发的开源工具，可以支持React，Vue，Angular等框架。</p>
<blockquote>
<p>它的网站首页这样说道：storybook 为UI组件提供一个独立的沙箱环境，在这里无论是edge case还是难于遇到的状态都可以造出来。可以把use case 像故事一样展现出来。</p>
</blockquote>
<p>平常的组件开发，程序猿需要把组件单独放置在一个页面不断的调试，非常不人性化。而storybook就单独为开发人员提供了一个页面，将组件放置在他们提供的页面中清晰可见。</p>
<p>简单的说，如果我们是开发react组件，就不需要启动react的打包编译启动页面浏览组件，只需要启动storybook为我们内置的页面即可浏览组建</p>
<p><img src="https://found-img-blog.oss-cn-hangzhou.aliyuncs.com/img/image-20220831232821238.png" alt="image-20220831232821238"></p>
<span id="more"></span>

<p>这样，单个组件的样式更好的展示出来。而且自动生成组件所需的API表</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这里我们以<code>React app</code>为例，如何在React脚手架中配置<code>storybook</code></p>
<p><span style="color:red">注意新旧版本示例文件有所不同!!!</span></p>
<ul>
<li>根目录执行：<code>npx -p @storybook/cli sb init</code><ul>
<li>自动配置项目并生成实例文件，如下：</li>
</ul>
</li>
</ul>
<p><img src="https://found-img-blog.oss-cn-hangzhou.aliyuncs.com/img/image-20220831233500985.png" alt="image-20220831233500985"></p>
<ul>
<li>启动：<code>yarn run storybook</code><ul>
<li>左边就是组件的目录</li>
</ul>
</li>
</ul>
<p><img src="https://found-img-blog.oss-cn-hangzhou.aliyuncs.com/img/image-20220831233608493.png" alt="image-20220831233608493"></p>
<h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>打开<code>Header.stories.jsx</code>文件</p>
<blockquote>
<p>我们可以在metadata 里面定义一些参数（parameters）这样可以提供一些配置上的灵活性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Header</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./Header&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Example/Header&#x27;</span>, <span class="comment">//---左侧目录配置</span></span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">Header</span>, <span class="comment">//---指定具体的组件</span></span><br><span class="line">  <span class="attr">parameters</span>: &#123; <span class="comment">//---自定义参数</span></span><br><span class="line">    <span class="attr">layout</span>: <span class="string">&#x27;fullscreen&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Template</span> = (<span class="params">args</span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">Header</span> &#123;<span class="attr">...args</span>&#125; /&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">LoggedIn</span> = <span class="title class_">Template</span>.<span class="title function_">bind</span>(&#123;&#125;);</span><br><span class="line"><span class="title class_">LoggedIn</span>.<span class="property">args</span> = &#123;</span><br><span class="line">  <span class="attr">user</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jane Doe&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">LoggedOut</span> = <span class="title class_">Template</span>.<span class="title function_">bind</span>(&#123;&#125;);</span><br><span class="line"><span class="title class_">LoggedOut</span>.<span class="property">args</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><code>LoggedIn.args</code>是配置组件属性的<em>默认值</em></p>
<p><img src="https://found-img-blog.oss-cn-hangzhou.aliyuncs.com/img/image-20220831235417873.png" alt="image-20220831235417873"></p>
<h2 id="配合Styled-components"><a href="#配合Styled-components" class="headerlink" title="配合Styled-components"></a>配合Styled-components</h2><p>配置<strong>Styled-components</strong>主题</p>
<p>因为storybook是独立于react creat app的，所以需要为storybook再配置一下主题</p>
<ul>
<li><p>在<code>.storybook</code>文件下创建<code>preview.js</code>文件</p>
</li>
<li><pre><code class="js">import React from &quot;react&quot;;
import &#123; addDecorator,addParameters &#125; from &quot;@storybook/react&quot;;
import &#123; ThemeProvider &#125; from &quot;styled-components&quot;;
import theme from &#39;../src/theme&#39;; //---theme为全局变量配置，类似less的全局变量配置文件

import &#39;story.css&#39;;

addDecorator((storyFn)=&gt;(
  &lt;ThemeProvider theme=&#123;theme&#125;&gt;&#123;storyFn()&#125;&lt;/ThemeProvider&gt;
))
</code></pre>
</li>
</ul>
<h2 id="更多…"><a href="#更多…" class="headerlink" title="更多…"></a>更多…</h2>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Storybook</tag>
        <tag>组件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>js闭包_深入浅出</title>
    <url>/2020/09/07/js-closure/</url>
    <content><![CDATA[<h2 id="简单的对闭包做一个理解："><a href="#简单的对闭包做一个理解：" class="headerlink" title="简单的对闭包做一个理解："></a>简单的对<strong>闭包</strong>做一个理解：</h2><ul>
<li>闭包产生是：函数内嵌套函数；</li>
<li>闭包函数在外面被调用，访问；</li>
<li>闭包能使外部函数访问内部函数的变量；</li>
<li>闭包可以保持对定义时的作用域的引用，使之不被销毁，就长生不老。</li>
</ul>
<span id="more"></span>

<h3 id="在看闭包之前我们还需要理解作用域。"><a href="#在看闭包之前我们还需要理解作用域。" class="headerlink" title="在看闭包之前我们还需要理解作用域。"></a>在看闭包之前我们还需要理解<strong>作用域</strong>。</h3><blockquote>
<p>作用域主要分为两种：全局变量和局部变量。</p>
</blockquote>
<h5 id="全局变量-amp-局部变量"><a href="#全局变量-amp-局部变量" class="headerlink" title="全局变量&amp;局部变量"></a><strong>全局变量&amp;局部变量</strong></h5><p><strong>局部变量</strong>:定义在函数内部，只能在函数中使用的变量，作用范围是从函数开始到结尾，即在<strong>｛｝</strong>里。<br>这里定义的<code>a</code>就是局部变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myTest1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//a is not defined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">myTest1</span>());<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p><strong>全局变量</strong>：常常定义在函数外部，拥有全局作用域，即在 JavaScript 代码的任何地方都可以访问</p>
<p>这里定义的<code>b</code>就是局部变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myTest2</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> b;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myTest2</span>());<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>从这里我们就可以知道，函数内部可以调用<strong>全局变量</strong>，但是函数外部无法读取函数内的<strong>局部变量</strong></p>
<p>函数内部声明变量的时候，必须使用var命令去声明一个变量。如果不用的话，就会声明了一个<strong>全局变量</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myTest3</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">4</span>;</span><br><span class="line">    d=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> c,d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">myTest3</span>());<span class="comment">//4,3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d);<span class="comment">//3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);<span class="comment">//c is not defined</span></span><br></pre></td></tr></table></figure>

<p>在这里我们<code>c</code>和<code>d</code>都是在函数内部声明的，但是因为<code>c</code>使用了<code>var</code>，而<code>d</code>没有使用<code>var</code>声明，所以在外部能够使用<code>d</code>；也就是所谓的声明了一个<strong>全局变量</strong></p>
<hr>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>在理解了<strong>全局变量</strong>和<strong>局部变量</strong>之后，我们先写一个简单的闭包实例给大家看看：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myTest4</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = <span class="title function_">myTest4</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">func</span>());<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p>在这里我们是不是有点明白了呢：如果我们想用一个变量或者得到一个变量，但是我们又不想全局声明定义这个变量，到这的时候我们就可以通过闭包来调用函数内部的变量。</p>
<p>但是我们也应该知道闭包产生的值是一直保存在内存中的。这里通过一个例子给大家看看：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myTest5</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = <span class="title function_">myTest5</span>();</span><br><span class="line"><span class="title function_">func</span>();<span class="comment">//4</span></span><br><span class="line"><span class="title function_">func</span>();<span class="comment">//5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">func</span>());<span class="comment">//6  </span></span><br></pre></td></tr></table></figure>

<p>这个例子就是说调用一次，然后<code>i</code>的值就变了一次并且会一直被保存，然后下次调用的时候就是上次保存的值了。</p>
<h5 id="一些闭包实例"><a href="#一些闭包实例" class="headerlink" title="一些闭包实例:"></a>一些闭包实例:</h5><p><strong>&#x2F;* 例子1 *&#x2F;</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFn</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">innerFn</span>(<span class="params"></span>)&#123;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> innerFn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> inner = <span class="title function_">outerFn</span>();  <span class="comment">//每次外部函数执行的时候,都会开辟一块内存空间,外部函数的地址不同，都会重新创建一个新的地址</span></span><br><span class="line"><span class="title function_">inner</span>(); <span class="comment">//1</span></span><br><span class="line"><span class="title function_">inner</span>(); <span class="comment">//2</span></span><br><span class="line"><span class="title function_">inner</span>(); <span class="comment">//3</span></span><br><span class="line"><span class="keyword">var</span> inner2 = <span class="title function_">outerFn</span>();</span><br><span class="line"><span class="title function_">inner2</span>(); <span class="comment">//1</span></span><br><span class="line"><span class="title function_">inner2</span>(); <span class="comment">//2</span></span><br><span class="line"><span class="title function_">inner2</span>(); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p><strong>&#x2F;* 例子2 *&#x2F;</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">m1</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(++x);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">m1</span>()();   <span class="comment">//2</span></span><br><span class="line"><span class="title function_">m1</span>()();   <span class="comment">//2</span></span><br><span class="line"><span class="title function_">m1</span>()();   <span class="comment">//2</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> m2 = <span class="title function_">m1</span>();</span><br><span class="line"><span class="title function_">m2</span>();   <span class="comment">//2</span></span><br><span class="line"><span class="title function_">m2</span>();   <span class="comment">//3</span></span><br><span class="line"><span class="title function_">m2</span>();   <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p><strong>&#x2F;* 例子3 *&#x2F;</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;lis.<span class="property">length</span>;i++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">      lis[i].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;)(i);       <span class="comment">//事件处理函数中闭包的写法</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<hr>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6><h4 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h4><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE浏览器中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>一个简单的回收实例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myTest6</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">var</span> i = <span class="number">4</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> i++;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">var</span> func = <span class="title function_">myTest5</span>();</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">func</span>());<span class="comment">//4</span></span><br><span class="line"> func = <span class="literal">null</span>;<span class="comment">//n被回收</span></span><br><span class="line"> <span class="keyword">var</span> func = <span class="title function_">myTest5</span>();</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">func</span>());<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>闭包的缺点就是常驻内存，闭包会使变量始终保存在内存中，如果使用不当会增大内存使用量，造成内存泄露。</p>
</li>
<li><p>正常情况下外部函数是不能访问内部函数的变量的，但是可以利用闭包来实现对函数内部变量的访问。</p>
</li>
<li><p>一般函数执行完毕后，局部活动对象就被销毁，内存中仅仅保存全局作用域。但闭包的情况不同！</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>在React项目中应用TypeScript</title>
    <url>/2020/09/07/react-typescript/</url>
    <content><![CDATA[<h2 id="如何在React项目中应用说说如何在反应项目中应用TypeScript"><a href="#如何在React项目中应用说说如何在反应项目中应用TypeScript" class="headerlink" title="如何在React项目中应用说说如何在反应项目中应用TypeScript?"></a>如何在React项目中应用说说如何在反应项目中应用TypeScript?</h2><p><img src="https://static.vue-js.com/a98974e0-13bc-11ec-a752-75723a64e8f5.png"></p>
<span id="more"></span>
<h2 id="一、前言："><a href="#一、前言：" class="headerlink" title="一、前言："></a>一、前言：</h2><p>使用 <code>TypeScript</code> 编写 <code>React</code> 代码，除了需要 <code>TypeScript</code> 这个库之外，还需要安装 <code>@types/react</code>、<code>@types/react-dom</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i @types/react -s   || yarn add @types/react -s</span><br><span class="line">npm i @types/react-dom -s  ||  yarn add @types/react-dom -s</span><br></pre></td></tr></table></figure>

<p>至于上述使用 <code>@types</code> 的库的原因在于，目前非常多的 <code>JavaScript</code> 库并没有提供自己关于 <code>TypeScript</code> 的声明文件</p>
<p>所以，<code>ts</code> 并不知道这些库的类型以及对应导出的内容，这里 <code>@types</code> 实际就是社区中的 <code>DefinitelyTyped</code> 库，定义了目前市面上绝大多数的 <code>JavaScript</code> 库的声明</p>
<p>所以下载相关的 <code>JavaScript</code> 对应的 <code>@types</code> 声明时，就能够使用使用该库对应的类型定义</p>
<hr>
<!--more-->

<h2 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h2><p>在编写 <code>React</code> 项目的时候，最常见的使用的组件就是：</p>
<ul>
<li>无状态组件</li>
<li>有状态组件</li>
<li>受控组件</li>
</ul>
<hr>
<h3 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件:"></a>无状态组件:</h3><p>主要作用是用于展示 <code>UI</code>，如果使用 <code>js</code> 声明，则如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;React&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Logo</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; logo, className, alt &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;logo&#125;</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span> <span class="attr">alt</span>=<span class="string">&#123;alt&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但这时候 <code>ts</code> 会出现报错提示，原因在于没有定义 <code>porps</code> 类型，这时候就可以使用 <code>interface</code> 接口去定义 <code>porps</code> 即可，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;React&quot;</span>;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IProps</span> &#123;</span><br><span class="line">  logo?: string;</span><br><span class="line">  className?: string;</span><br><span class="line">  alt?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Logo</span> = (<span class="params">props: IProps</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; logo, className, alt &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;logo&#125;</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span> <span class="attr">alt</span>=<span class="string">&#123;alt&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是我们都知道 <code>props</code> 里面存在 <code>children</code> 属性，我们不可能每个 <code>porps</code> 接口里面定义多一个 <code>children</code>，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">IProps</span> &#123;</span><br><span class="line">  logo?: string;</span><br><span class="line">  className?: string;</span><br><span class="line">  alt?: string;</span><br><span class="line">  children?: <span class="title class_">ReactNode</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更加规范的写法是使用 <code>React</code> 里面定义好的 <code>FC</code> 属性，里面已经定义好 <code>children</code> 类型，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Logo</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">IProps</span>&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; logo, className, alt &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;logo&#125;</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span> <span class="attr">alt</span>=<span class="string">&#123;alt&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="有状态组件"><a href="#有状态组件" class="headerlink" title="有状态组件:"></a>有状态组件:</h3><p>可以是一个类组件且存在 <code>props</code> 和 <code>state</code> 属性</p>
<p>如果使用 <code>TypeScript</code> 声明则如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;React&quot;</span>;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IProps</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: string;</span><br><span class="line">  size?: string;</span><br><span class="line">&#125;</span><br><span class="line">interface <span class="title class_">IState</span> &#123;</span><br><span class="line">  <span class="attr">count</span>: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&lt;<span class="title class_">IProps</span>, <span class="title class_">IState</span>&gt; &#123;</span><br><span class="line">  public state = &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  public <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述通过泛型对 <code>props</code>、<code>state</code> 进行类型定义，然后在使用的时候就可以在编译器中获取更好的智能提示</p>
<p>关于 <code>Component</code> 泛型类的定义，可以参考下 React 的类型定义文件 <code>node_modules/@types/React/index.d.ts</code>，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span>&lt;P, S&gt; &#123;</span><br><span class="line">  readonly <span class="attr">props</span>: <span class="title class_">Readonly</span>&lt;&#123; children?: <span class="title class_">ReactNode</span> &#125;&gt; &amp; <span class="title class_">Readonly</span>&lt;P&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="attr">state</span>: <span class="title class_">Readonly</span>&lt;S&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述可以看到，<code>state</code> 属性也定义了可读类型，目的是为了防止直接调用 <code>this.state</code> 更新状态</p>
<hr>
<h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件:"></a>受控组件:</h3><p>受控组件的特性在于元素的内容通过组件的状态 <code>state</code> 进行控制</p>
<p>由于组件内部的事件是合成事件，不等同于原生事件，</p>
<p>例如一个 <code>input</code> 组件修改内部的状态，常见的定义的时候如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">private <span class="title function_">updateValue</span>(<span class="params">e: React.ChangeEvent&lt;HTMLInputElement&gt;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">itemText</span>: e.<span class="property">target</span>.<span class="property">value</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>上述只是简单的在 <code>React</code> 项目使用 <code>TypeScript</code>，但在编写 <code>React</code> 项目的时候，还存在 <code>hooks</code>、默认参数、以及 <code>store</code> 等等……</p>
<hr>
<blockquote>
<p>基于hexo搭建的一个博客:<a href="https://nanxiangscholar.github.io/">https://nanxiangscholar.github.io/</a></p>
<p>欢迎访问!</p>
</blockquote>
]]></content>
      <categories>
        <category>TypeScript</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>在Vue项目中应用TypeScript</title>
    <url>/2021/09/12/vue-typescript/</url>
    <content><![CDATA[<h1 id="如何在Vue项目中应用TypeScript？"><a href="#如何在Vue项目中应用TypeScript？" class="headerlink" title="如何在Vue项目中应用TypeScript？"></a>如何在Vue项目中应用TypeScript？</h1><p><img src="https://static.vue-js.com/cc658c10-1565-11ec-8e64-91fdec0f05a1.png"></p>
<hr>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在<code>VUE</code>项目中应用<code>typescript</code>，我们需要引入一个库<code>vue-property-decorator</code>，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># npm 下载</span><br><span class="line">npm i vue-property-decorator -s</span><br><span class="line"># yarn 下载</span><br><span class="line">yarn add vue-property-decorator -s</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>其是基于<code>vue-class-component</code>库而来，这个库<code>vue</code>官方推出的一个支持使用<code>class</code>方式来开发<code>vue</code>单文件组件的库</p>
<p>主要的功能如下：</p>
<ul>
<li>methods 可以直接声明为类的成员方法</li>
<li>计算属性可以被声明为类的属性访问器</li>
<li>初始化的 data 可以被声明为类属性</li>
<li>data、render 以及所有的 Vue 生命周期钩子可以直接作为类的成员方法</li>
<li>所有其他属性，需要放在装饰器中</li>
</ul>
<h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><p><code>vue-property-decorator</code> 主要提供了多个装饰器和一个函数:</p>
<ul>
<li>@Prop</li>
<li>@PropSync</li>
<li>@Model</li>
<li>@Watch</li>
<li>@Provide</li>
<li>@Inject</li>
<li>@ProvideReactive</li>
<li>@InjectReactive</li>
<li>@Emit</li>
<li>@Ref</li>
<li>@Component (由 vue-class-component 提供)</li>
<li>Mixins (由 vue-class-component 提供)</li>
</ul>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p><code>Component</code>装饰器它注明了此类为一个<code>Vue</code>组件，因此即使没有设置选项也不能省略</p>
<p>如果需要定义比如 <code>name</code>、<code>components</code>、<code>filters</code>、<code>directives</code>以及自定义属性，就可以在<code>Component</code>装饰器中定义，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Component</span>,<span class="title class_">Vue</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;componentA,componentB&#125; <span class="keyword">from</span> <span class="string">&#x27;@/components&#x27;</span>;</span><br><span class="line"></span><br><span class="line"> @<span class="title class_">Component</span>(&#123;</span><br><span class="line">    <span class="attr">components</span>:&#123;</span><br><span class="line">        componentA,</span><br><span class="line">        componentB,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">directives</span>: &#123;</span><br><span class="line">        <span class="attr">focus</span>: &#123;</span><br><span class="line">            <span class="comment">// 指令的定义</span></span><br><span class="line">            <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">                el.<span class="title function_">focus</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">YourCompoent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="computed、data、methods"><a href="#computed、data、methods" class="headerlink" title="computed、data、methods"></a>computed、data、methods</h3><p>这里取消了组件的data和methods属性，以往data返回对象中的属性、methods中的方法需要直接定义在Class中，当做类的属性和方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">HelloDecorator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">    <span class="attr">count</span>: number = <span class="number">123</span> <span class="comment">// 类属性相当于以前的 data</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">add</span>(): number &#123; <span class="comment">// 类方法就是以前的方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取计算属性</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">total</span>(): number &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置计算属性</span></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">total</span>(<span class="params">param:number</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span> = param</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="props"><a href="#props" class="headerlink" title="@props"></a>@props</h3><p>组件接收属性的装饰器，如下使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Component</span>,<span class="title class_">Vue</span>,<span class="title class_">Prop</span>&#125; <span class="keyword">from</span> vue-property-decorator;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">YourComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">    @<span class="title class_">Prop</span>(<span class="title class_">String</span>)</span><br><span class="line">    <span class="attr">propA</span>:string;</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Prop</span>([<span class="title class_">String</span>,<span class="title class_">Number</span>])</span><br><span class="line">    <span class="attr">propB</span>:string|number;</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Prop</span>(&#123;</span><br><span class="line">     <span class="attr">type</span>: <span class="title class_">String</span>, <span class="comment">// type: [String , Number]</span></span><br><span class="line">     <span class="attr">default</span>: <span class="string">&#x27;default value&#x27;</span>, <span class="comment">// 一般为String或Number</span></span><br><span class="line">      <span class="comment">//如果是对象或数组的话。默认值从一个工厂函数中返回</span></span><br><span class="line">      <span class="comment">// defatult: () =&gt; &#123;</span></span><br><span class="line">      <span class="comment">//     return [&#x27;a&#x27;,&#x27;b&#x27;]</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">     <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">     <span class="attr">validator</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">          <span class="string">&#x27;InProcess&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Settled&#x27;</span></span><br><span class="line">        ].<span class="title function_">indexOf</span>(value) !== -<span class="number">1</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="attr">propC</span>:string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="watch"><a href="#watch" class="headerlink" title="@watch"></a>@watch</h3><p>实际就是<code>Vue</code>中的监听器，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Vue</span>, <span class="title class_">Component</span>, <span class="title class_">Watch</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">YourComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  @<span class="title class_">Watch</span>(<span class="string">&#x27;child&#x27;</span>)</span><br><span class="line">  <span class="title function_">onChildChanged</span>(<span class="params">val: string, oldVal: string</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title class_">Watch</span>(<span class="string">&#x27;person&#x27;</span>, &#123; <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="attr">deep</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="title function_">onPersonChanged1</span>(<span class="params">val: Person, oldVal: Person</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title class_">Watch</span>(<span class="string">&#x27;person&#x27;</span>)</span><br><span class="line">  <span class="title function_">onPersonChanged2</span>(<span class="params">val: Person, oldVal: Person</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="emit"><a href="#emit" class="headerlink" title="@emit"></a>@emit</h3><p><code>vue-property-decorator</code> 提供的 <code>@Emit</code> 装饰器就是代替<code>Vue</code>中的事件的触发<code>$emit</code>，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Vue</span>, <span class="title class_">Component</span>, <span class="title class_">Emit</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="line">    @<span class="title class_">Component</span>(&#123;&#125;)</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Some</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span>&#123;</span><br><span class="line">        <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.$on(<span class="string">&#x27;emit-todo&#x27;</span>, <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">emitTodo</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        @<span class="title class_">Emit</span>()</span><br><span class="line">        <span class="title function_">emitTodo</span>(<span class="params">n: string</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="三-、总结"><a href="#三-、总结" class="headerlink" title="三 、总结"></a>三 、总结</h2><p>可以看到上述<code>typescript</code>版本的<code>vue class</code>的语法与平时<code>javascript</code>版本使用起来还是有很大的不同，多处用到<code>class</code>与装饰器，但实际上本质是一致的，只有不断编写才会得心应手。</p>
<hr>
<blockquote>
<p>基于hexo搭建的一个博客:<a href="https://nanxiangscholar.github.io/">https://nanxiangscholar.github.io/</a></p>
<p>欢迎访问!</p>
</blockquote>
]]></content>
      <categories>
        <category>TypeScript</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>手写setTimeout和setInterval</title>
    <url>/2020/09/07/setTimeout-setIterval/</url>
    <content><![CDATA[<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>写代码之前需要知道<em>setTimeout</em>实现原理：本质上就是在给定的时间向任务队列添加回调函数，并执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mySetTimeout</span>(<span class="params">...rest</span>)&#123;</span><br><span class="line">      <span class="comment">// 1.得到调用setTimeoutMy函数时的时间戳</span></span><br><span class="line">      <span class="keyword">let</span> start =<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">      <span class="comment">// 2.得到回调函数结束的时间</span></span><br><span class="line">      <span class="keyword">let</span> end = start+ rest[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 3. 监听事件变化，当事件到达指定的结束时间时，结束回调函数</span></span><br><span class="line">      <span class="keyword">let</span> timer =<span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">let</span> time =<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">          <span class="keyword">if</span>(time&gt;=end)&#123;</span><br><span class="line">             <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">             rest[<span class="number">0</span>](rest[<span class="number">2</span>]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,<span class="number">17</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;同步执行----&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mySetTimeout</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;,<span class="number">1000</span>,<span class="string">&#x27;执行结果&#x27;</span>)</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">  同步执行---- # 从这里可以看出<span class="built_in">setTimeout</span>本身执行是同步的，执行的回调函数是异步的</span><br><span class="line">  执行结果  # 输出结果，是在<span class="number">1</span>秒之后输出</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<hr>
<h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><p>写代码之前需要知道<em>setInterval</em>实现原理：本质上就是每隔一定的时间向任务队列添加回调函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mySetInterval</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rest数组接受三个参数:</span></span><br><span class="line"><span class="comment">     *  1)回调函数               rest[0]</span></span><br><span class="line"><span class="comment">     *  2)执行回调函数所需的时间  rest[1]</span></span><br><span class="line"><span class="comment">     *  3)操作元素               rest[2]  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">interval</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rest[<span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2:利用setTimeout在给定的时间，就调用回调函数的原理,使用递归思想，自己调用自己.</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(interval, rest[<span class="number">1</span>])</span><br><span class="line">            rest[<span class="number">0</span>]();</span><br><span class="line">            rest[<span class="number">2</span>]--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 3：条件不符合，退出函数</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1:利用setTimeout在mySetInterval被调用时异步调用一次。</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(interval, rest[<span class="number">1</span>]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;同步执行----&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">mySetInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">-----------</span><br><span class="line">结果：</span><br><span class="line">	同步执行----  # 从这里可以看出setIterval本身执行是同步的，执行的回调函数是异步的</span><br><span class="line">	<span class="number">1</span></span><br><span class="line">	<span class="number">1</span></span><br><span class="line">	<span class="number">1</span></span><br><span class="line">	<span class="number">1</span></span><br><span class="line">	<span class="number">1</span></span><br><span class="line">	<span class="number">1</span></span><br><span class="line">	<span class="number">1</span></span><br><span class="line">	<span class="number">1</span>  # 输出<span class="number">8</span>次<span class="number">1</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论:"></a>结论:</h3><blockquote>
<p>setTimeout:</p>
<blockquote>
<p>1.得到调用setTimeoutMy函数时的时间戳；</p>
<p>2.得到回调函数结束的时间；</p>
<p>3.监听事件变化，当事件到达指定的结束时间时，结束回调函数。</p>
</blockquote>
</blockquote>
<blockquote>
<p>setIterval:</p>
<blockquote>
<p>1:利用setTimeout在mySetInterval被调用时异步调用一次;</p>
<p>2:利用setTimeout在给定的时间，就调用回调函数的原理,使用递归思想，自己调用自己。</p>
</blockquote>
</blockquote>
<h6 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h6><p><em>setTimeout</em>和<em>setIterval</em>本身执行是同步的，执行的回调函数是异步的。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>手写instanceof</title>
    <url>/2022/09/17/instanceof/</url>
    <content><![CDATA[<h2 id="手写instanceof"><a href="#手写instanceof" class="headerlink" title="手写instanceof"></a>手写instanceof</h2><p>首先写之前要先理解一下<strong>instanceof</strong>的实现原理:</p>
<ul>
<li><strong>instanceof</strong> 主要的实现原理就是只要右边变量的<strong>prototype</strong>在左边变量的原型链上即可(<em><strong>也就是说左边的变量能在原型链上找到左边变量的prototype)</strong></em></li>
</ul>
<hr>
<span id="more"></span>

<p>了解原理之后开始看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 声明myInstanceof函数,接受两个参数left, right</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">myInstanceOf</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">        <span class="comment">// 1:声明rightval变量，来得到传入的对象的原型对象</span></span><br><span class="line">        <span class="keyword">let</span> rightVal = right.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">        <span class="comment">// 2:声明leftval变量，来得到传入的对象的原型对象</span></span><br><span class="line">        <span class="keyword">let</span> leftVal = left.<span class="property">__proto__</span></span><br><span class="line">        <span class="comment">// 3：循环遍历左边变量的原型链，查找，如果找不到就到一直循环到父类型或祖类型</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftVal === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (leftVal === rightVal) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            leftVal = leftVal.<span class="property">__proto__</span> <span class="comment">// 获取祖类型的__proto__</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例:</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"> <span class="keyword">let</span> test = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceOf</span>(test, <span class="title class_">Test</span>));</span><br><span class="line"></span><br><span class="line"> ------------------</span><br><span class="line"> 结果：</span><br><span class="line"> <span class="literal">true</span>  </span><br></pre></td></tr></table></figure>



<h5 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h5><blockquote>
<p>instanceof在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false.</p>
</blockquote>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>web常见的攻击方式</title>
    <url>/2021/09/23/web-attack/</url>
    <content><![CDATA[<h1 id="web常见的攻击方式有哪些？如何防御？"><a href="#web常见的攻击方式有哪些？如何防御？" class="headerlink" title="web常见的攻击方式有哪些？如何防御？"></a>web常见的攻击方式有哪些？如何防御？</h1><br>

<h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>Web攻击（WebAttack）是针对用户上网行为或网站服务器等设备进行攻击的行为</p>
<p>首先常见的Web攻击方式有</p>
<ul>
<li>XSS (Cross Site Scripting) 跨站脚本攻击</li>
<li>CSRF（Cross-site request forgery）跨站请求伪造</li>
<li>SQL注入攻击</li>
</ul>
<span id="more"></span>

<h2 id="二、XSS"><a href="#二、XSS" class="headerlink" title="二、XSS"></a>二、XSS</h2><p>XSS，跨站脚本攻击，允许攻击者将恶意代码植入到提供给其它用户使用的页面中</p>
<p><code>XSS</code>涉及到三方，即攻击者、客户端与<code>Web</code>应用</p>
<p><code>XSS</code>的攻击目标是为了盗取存储在客户端的<code>cookie</code>或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互</p>
<p>举个例子：</p>
<p>一个搜索页面，根据<code>url</code>参数决定关键词的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;&lt;%= getParameter(&quot;</span>keyword<span class="string">&quot;) %&gt;&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  您搜索的关键词是：&lt;%= getParameter(&quot;keyword&quot;) %&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>这里看似并没有问题，但是如果不按套路出牌呢？</p>
<p>用户输入<code>&quot;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code>，拼接到 HTML 中返回给浏览器。形成了如下的 HTML：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;&quot;</span>&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;XSS&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;button&gt;搜索&lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">  您搜索的关键词是：&quot;</span>&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;XSS&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>浏览器无法分辨出 <code>&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code> 是恶意代码，因而将其执行，试想一下，如果是获取<code>cookie</code>发送对黑客服务器呢？</p>
<p>根据攻击的来源，<code>XSS</code>攻击可以分成：</p>
<ul>
<li>存储型</li>
<li>反射型</li>
<li>DOM 型</li>
</ul>
<h3 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h3><p>存储型 XSS 的攻击步骤：</p>
<ol>
<li>攻击者将恶意代码提交到目标网站的数据库中</li>
<li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li>
</ol>
<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等</p>
<h3 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h3><p>反射型 XSS 的攻击步骤：</p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码</li>
<li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li>
</ol>
<p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</p>
<p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。</p>
<p>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</p>
<p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见</p>
<h3 id="DOM-型-XSS"><a href="#DOM-型-XSS" class="headerlink" title="DOM 型 XSS"></a>DOM 型 XSS</h3><p>DOM 型 XSS 的攻击步骤：</p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码</li>
<li>用户打开带有恶意代码的 URL</li>
<li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li>
</ol>
<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞</p>
<h3 id="XSS的预防"><a href="#XSS的预防" class="headerlink" title="XSS的预防"></a>XSS的预防</h3><p>通过前面介绍，看到<code>XSS</code>攻击的两大要素：</p>
<ul>
<li>攻击者提交而恶意代码</li>
<li>浏览器执行恶意代码</li>
</ul>
<p>针对第一个要素，我们在用户输入的过程中，过滤掉用户输入的恶劣代码，然后提交给后端，但是如果攻击者绕开前端请求，直接构造请求就不能预防了</p>
<p>而如果在后端写入数据库前，对输入进行过滤，然后把内容给前端，但是这个内容在不同地方就会有不同显示</p>
<p>例如：</p>
<p>一个正常的用户输入了 <code>5 &lt; 7</code> 这个内容，在写入数据库前，被转义，变成了 <code>5 &lt; 7</code></p>
<p>在客户端中，一旦经过了 <code>escapeHTML()</code>，客户端显示的内容就变成了乱码( <code>5 &lt; 7</code> )</p>
<p>在前端中，不同的位置所需的编码也不同。</p>
<ul>
<li>当 <code>5 &lt; 7</code> 作为 HTML 拼接页面时，可以正常显示：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div title=<span class="string">&quot;comment&quot;</span>&gt;<span class="number">5</span> &amp;lt; <span class="number">7</span>&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>当 <code>5 &lt; 7</code> 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等</li>
</ul>
<p>可以看到，过滤并非可靠的，下面就要通过防止浏览器执行恶意代码：</p>
<p>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等</p>
<p>如果用 <code>Vue/React</code> 技术栈，并且不使用 <code>v-html</code>&#x2F;<code>dangerouslySetInnerHTML</code> 功能，就在前端 <code>render</code> 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患</p>
<p>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 链接内包含恶意代码 --&gt;</span><br><span class="line">&lt; a href=<span class="string">&quot; &quot;</span>&gt;<span class="number">1</span>&lt;/ a&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// setTimeout()/setInterval() 中调用恶意代码</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// location 调用恶意代码</span></span><br><span class="line">location.<span class="property">href</span> = <span class="string">&#x27;UNTRUSTED&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eval() 中调用恶意代码</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="三、CSRF"><a href="#三、CSRF" class="headerlink" title="三、CSRF"></a>三、CSRF</h2><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求</p>
<p>利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目</p>
<p>一个典型的CSRF攻击有着如下的流程：</p>
<ul>
<li>受害者登录a.com，并保留了登录凭证（Cookie）</li>
<li>攻击者引诱受害者访问了b.com</li>
<li>b.com 向 a.com 发送了一个请求：a.com&#x2F;act&#x3D;xx。浏览器会默认携带a.com的Cookie</li>
<li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求</li>
<li>a.com以受害者的名义执行了act&#x3D;xx</li>
<li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作</li>
</ul>
<p><code>csrf</code>可以通过<code>get</code>请求，即通过访问<code>img</code>的页面后，浏览器自动访问目标地址，发送请求</p>
<p>同样，也可以设置一个自动提交的表单发送<code>post</code>请求，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;https://nanxiangscholar.github.io/&quot;</span> method=<span class="variable constant_">POST</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xiaoming&quot;</span> /&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;for&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">submit</span>(); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> </span><br></pre></td></tr></table></figure>

<p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次<code>POST</code>操作</p>
<p>还有一种为使用<code>a</code>标签的，需要用户点击链接才会触发</p>
<p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">## 测试网络地址</span><br><span class="line">&lt; a href=<span class="string">&quot;https://nanxiangscholar.github.io/&quot;</span> taget=<span class="string">&quot;_blank&quot;</span>&gt;</span><br><span class="line">    重磅消息！！</span><br><span class="line">&lt;a/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="CSRF的特点"><a href="#CSRF的特点" class="headerlink" title="CSRF的特点"></a>CSRF的特点</h3><ul>
<li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生</li>
<li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据</li>
<li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”</li>
<li>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪</li>
</ul>
<h3 id="CSRF的预防"><a href="#CSRF的预防" class="headerlink" title="CSRF的预防"></a>CSRF的预防</h3><p>CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性</p>
<p>防止<code>csrf</code>常用方案如下：</p>
<ul>
<li>阻止不明外域的访问<ul>
<li>同源检测</li>
<li>Samesite Cookie</li>
</ul>
</li>
<li>提交时要求附加本域才能获取的信息<ul>
<li>CSRF Token</li>
<li>双重Cookie验证</li>
</ul>
</li>
</ul>
<p>这里主要讲讲<code>token</code>这种形式，流程如下：</p>
<ul>
<li>用户打开页面的时候，服务器需要给这个用户生成一个Token</li>
<li>对于GET请求，Token将附在请求地址之后。对于 POST 请求来说，要在 form 的最后加上</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性</li>
</ul>
<h2 id="四、SQL注入"><a href="#四、SQL注入" class="headerlink" title="四、SQL注入"></a>四、SQL注入</h2><p>Sql 注入攻击，是通过将恶意的 <code>Sql</code>查询或添加语句插入到应用的输入参数中，再在后台 <code>Sql</code>服务器上解析执行进行的攻击:</p>
<p><img src="D:\桌面\ead52fa0-8d1d-11eb-85f6-6fac77c0c9b3.png"></p>
<p>流程如下所示：</p>
<ul>
<li>找出SQL漏洞的注入点</li>
<li>判断数据库的类型以及版本</li>
<li>猜解用户名和密码</li>
<li>利用工具查找Web后台管理入口</li>
<li>入侵和破坏</li>
</ul>
<p>预防方式如下：</p>
<ul>
<li>严格检查输入变量的类型和格式</li>
<li>过滤和转义特殊字符</li>
<li>对访问数据库的Web应用程序采用Web应用防火墙</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript快速入门</title>
    <url>/2021/09/26/TypeScript/</url>
    <content><![CDATA[<h1 id="TypeScript快速入门"><a href="#TypeScript快速入门" class="headerlink" title="TypeScript快速入门"></a>TypeScript快速入门</h1><hr>
<br>

<h2 id="1、TypeScript简介"><a href="#1、TypeScript简介" class="headerlink" title="1、TypeScript简介"></a>1、TypeScript简介</h2><ul>
<li><p>ts是js的超集，存在类型的脚本语言;</p>
</li>
<li><p>继承了js的所有编程类型，js代码可在ts环境很好的运行;</p>
</li>
<li><p>新增类型注解和类型推断</p>
</li>
<li><p>拥有丰富的class扩展功能</p>
</li>
<li><p>强大的类型系统，拥有静态类型检查能力</p>
</li>
</ul>
 <br>

<span id="more"></span>
<h2 id="2、基本类型"><a href="#2、基本类型" class="headerlink" title="2、基本类型"></a>2、基本类型</h2><ul>
<li><p>类型声明</p>
<ul>
<li><p>类型声明是TS非常重要的一个特点</p>
</li>
<li><p>通过类型声明可以指定TS中变量（参数、形参）的类型</p>
</li>
<li><p>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错</p>
</li>
<li><p>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值</p>
</li>
<li><p>语法：</p>
<ul>
<li><p>&#96;&#96;&#96;typescript<br>let 变量: 类型;</p>
<p>let 变量: 类型 &#x3D; 值;</p>
<p>function fn(参数: 类型, 参数: 类型): 类型{<br>…<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 自动类型判断</span><br><span class="line"></span><br><span class="line">  - TS拥有自动的类型判断机制</span><br><span class="line">  - 当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型</span><br><span class="line">  - 所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明</span><br><span class="line"></span><br><span class="line">- 类型：</span><br><span class="line"></span><br><span class="line">  |  类型   |       例子        |              描述              |</span><br><span class="line">  | :-----: | :---------------: | :----------------------------: |</span><br><span class="line">  | number  |    1, -33, 2.5    |            任意数字            |</span><br><span class="line">  | string  | &#x27;hi&#x27;, &quot;hi&quot;, `hi`  |           任意字符串           |</span><br><span class="line">  | boolean |    true、false    |       布尔值true或false        |</span><br><span class="line">  | 字面量  |      其本身       |  限制变量的值就是该字面量的值  |</span><br><span class="line">  |   any   |         *         |            任意类型            |</span><br><span class="line">  | unknown |         *         |         类型安全的any          |</span><br><span class="line">  |  void   | 空值（undefined） |     没有值（或undefined）      |</span><br><span class="line">  |  never  |      没有值       |          不能是任何值          |</span><br><span class="line">  | object  |  &#123;name:&#x27;孙悟空&#x27;&#125;  |          任意的JS对象          |</span><br><span class="line">  |  array  |      [1,2,3]      |           任意JS数组           |</span><br><span class="line">  |  tuple  |       [4,5]       | 元组，TS新增类型，固定长度数组 |</span><br><span class="line">  |  enum   |    enum&#123;A, B&#125;     |       枚举，TS中新增类型       |</span><br><span class="line"></span><br><span class="line">- number(数字型)</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let decimal: number = 6;</span><br><span class="line">    let hex: number = 0xf00d;</span><br><span class="line">    let binary: number = 0b1010;</span><br><span class="line">    let octal: number = 0o744;</span><br><span class="line">    let big: bigint = 100n;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>boolean(布尔型)</p>
<ul>
<li>&#96;&#96;&#96;typescript<br>let isDone: boolean &#x3D; false;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- string(字符串型)</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let color: string = &quot;blue&quot;;</span><br><span class="line">    color = &#x27;red&#x27;;</span><br><span class="line">    </span><br><span class="line">    let fullName: string = `Bob Bobbington`;</span><br><span class="line">    let age: number = 37;</span><br><span class="line">    let sentence: string = `Hello, my name is $&#123;fullName&#125;.</span><br><span class="line">    </span><br><span class="line">    I&#x27;ll be $&#123;age + 1&#125; years old next month.`;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>字面量</p>
<ul>
<li><p>也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围</p>
</li>
<li><p>&#96;&#96;&#96;typescript<br>let color: ‘red’ | ‘blue’ | ‘black’;<br>let num: 1 | 2 | 3 | 4 | 5;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- any(任意型)</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let d: any = 4;</span><br><span class="line">    d = &#x27;hello&#x27;;</span><br><span class="line">    d = true;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>unknown(类型安全的any)；</p>
<ul>
<li><p><strong>注意</strong>:unknown和any都是TS中的顶级类型，但主要区别在于：<strong>使用any相当于彻底放弃了类型检查</strong>，而unknown类型相较于any更加严格，在执行大多数操作之前，会进行某种形式的检查(不允许访问属性，不允许赋值给其他有明确类型的变量)。</p>
</li>
<li><p>&#96;&#96;&#96;typescript<br>let notSure: unknown &#x3D; 4;<br>notSure &#x3D; ‘hello’;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- void</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let unusable: void = undefined;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>never</p>
<ul>
<li>&#96;&#96;&#96;typescript<br>function error(message: string): never {<br>  throw new Error(message);<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- object(不怎么用)</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let obj: object = &#123;&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>array</p>
<ul>
<li>&#96;&#96;&#96;typescript<br>let list: number[] &#x3D; [1, 2, 3];<br>let list: Array<number> &#x3D; [1, 2, 3];<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- tuple</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let x: [string, number];</span><br><span class="line">    x = [&quot;hello&quot;, 10]; </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>enum</p>
<ul>
<li><p>&#96;&#96;&#96;typescript<br>enum Color {<br>  Red,<br>  Green,<br>  Blue,<br>}<br>let c: Color &#x3D; Color.Green;</p>
<p>enum Color {<br>  Red &#x3D; 1,<br>  Green,<br>  Blue,<br>}<br>let c: Color &#x3D; Color.Green;</p>
<p>enum Color {<br>  Red &#x3D; 1,<br>  Green &#x3D; 2,<br>  Blue &#x3D; 4,<br>}<br>let c: Color &#x3D; Color.Green;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 类型断言</span><br><span class="line"></span><br><span class="line">  - 类型断言就相当于在编译阶段进行类型转换；</span><br><span class="line"></span><br><span class="line">  - 有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</span><br><span class="line"></span><br><span class="line">    - 第一种</span><br><span class="line">  </span><br><span class="line">      - ```typescript</span><br><span class="line">        let someValue: unknown = &quot;this is a string&quot;;</span><br><span class="line">        let strLength: number = (someValue as string).length;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第二种</p>
<ul>
<li>&#96;&#96;&#96;typescript<br>let someValue: unknown &#x3D; “this is a string”;<br>let strLength: number &#x3D; (<string>someValue).length;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">## 3、编译选项</span><br><span class="line"></span><br><span class="line">- 自动编译文件</span><br><span class="line"></span><br><span class="line">  - 编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```powershell</span><br><span class="line">      tsc xxx.ts -w</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>自动编译整个项目</p>
<ul>
<li><p>如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。</p>
</li>
<li><p>但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json</p>
</li>
<li><p>tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译</p>
</li>
<li><p>配置选项：</p>
<ul>
<li><p>include</p>
<ul>
<li><p>定义希望被编译文件所在的目录</p>
</li>
<li><p>默认值：[“**&#x2F;*“]</p>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="json">&quot;include&quot;:[&quot;src/**/*&quot;, &quot;tests/**/*&quot;]
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 上述示例中，所有src目录和tests目录下的文件都会被编译</span><br><span class="line"></span><br><span class="line">- exclude</span><br><span class="line"></span><br><span class="line">  - 定义需要排除在外的目录</span><br><span class="line"></span><br><span class="line">  - 默认值：[&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;]</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;exclude&quot;: [&quot;./src/hello/**/*&quot;]</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>上述示例中，src下hello目录下的文件都不会被编译</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>extends</p>
<ul>
<li><p>定义被继承的配置文件</p>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="json">&quot;extends&quot;: &quot;./configs/base&quot;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息</span><br><span class="line"></span><br><span class="line">- files</span><br><span class="line"></span><br><span class="line">  - 指定被编译文件的列表，只有需要编译的文件少时才会用到</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;files&quot;: [</span><br><span class="line">          &quot;core.ts&quot;,</span><br><span class="line">          &quot;sys.ts&quot;,</span><br><span class="line">          &quot;types.ts&quot;,</span><br><span class="line">          &quot;scanner.ts&quot;,</span><br><span class="line">          &quot;parser.ts&quot;,</span><br><span class="line">          &quot;utilities.ts&quot;,</span><br><span class="line">          &quot;binder.ts&quot;,</span><br><span class="line">          &quot;checker.ts&quot;,</span><br><span class="line">          &quot;tsc.ts&quot;</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>列表中的文件都会被TS编译器所编译</p>
</li>
</ul>
</li>
<li><p>compilerOptions</p>
<ul>
<li><p>编译选项是配置文件中非常重要也比较复杂的配置选项</p>
</li>
<li><p>在compilerOptions中包含多个子选项，用来完成对编译的配置</p>
<ul>
<li><p>项目选项</p>
<ul>
<li><p>target</p>
<ul>
<li><p>设置ts代码编译的目标版本</p>
</li>
<li><p>可选值：</p>
<ul>
<li>ES3（默认）、ES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li>&#96;&#96;&#96;json<br>“compilerOptions”: {<br>“target”: “ES6”<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码</span><br><span class="line"></span><br><span class="line">- lib</span><br><span class="line"></span><br><span class="line">  - 指定代码运行时所包含的库（宿主环境）</span><br><span class="line"></span><br><span class="line">  - 可选值：</span><br><span class="line"></span><br><span class="line">    - ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;compilerOptions&quot;: &#123;</span><br><span class="line">          &quot;target&quot;: &quot;ES6&quot;,</span><br><span class="line">          &quot;lib&quot;: [&quot;ES6&quot;, &quot;DOM&quot;],</span><br><span class="line">          &quot;outDir&quot;: &quot;dist&quot;,</span><br><span class="line">          &quot;outFile&quot;: &quot;dist/aa.js&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>module</p>
<ul>
<li><p>设置编译后代码使用的模块化系统</p>
</li>
<li><p>可选值：</p>
<ul>
<li>CommonJS、UMD、AMD、System、ES2020、ESNext、None</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="typescript">&quot;compilerOptions&quot;: &#123;
    &quot;module&quot;: &quot;CommonJS&quot;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- outDir</span><br><span class="line"></span><br><span class="line">  - 编译后文件的所在目录</span><br><span class="line"></span><br><span class="line">  - 默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;compilerOptions&quot;: &#123;</span><br><span class="line">          &quot;outDir&quot;: &quot;dist&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>设置后编译后的js文件将会生成到dist目录</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>outFile</p>
<ul>
<li><p>将所有的文件编译为一个js文件</p>
</li>
<li><p>默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中</p>
</li>
<li><p>示例：</p>
<ul>
<li>&#96;&#96;&#96;json<br>“compilerOptions”: {<br>“outFile”: “dist&#x2F;app.js”<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- rootDir</span><br><span class="line"></span><br><span class="line">  - 指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;compilerOptions&quot;: &#123;</span><br><span class="line">          &quot;rootDir&quot;: &quot;./src&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>allowJs</p>
<ul>
<li>是否对js文件编译</li>
</ul>
</li>
<li><p>checkJs</p>
<ul>
<li><p>是否对js文件进行检查</p>
</li>
<li><p>示例：</p>
<ul>
<li>&#96;&#96;&#96;json<br>“compilerOptions”: {<br>“allowJs”: true,<br>“checkJs”: true<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">            - removeComments</span><br><span class="line"></span><br><span class="line">              - 是否删除注释</span><br><span class="line">              - 默认值：false</span><br><span class="line"></span><br><span class="line">            - noEmit</span><br><span class="line"></span><br><span class="line">              - 不对代码进行编译</span><br><span class="line">              - 默认值：false</span><br><span class="line"></span><br><span class="line">            - sourceMap</span><br><span class="line"></span><br><span class="line">              - 是否生成sourceMap</span><br><span class="line">              - 默认值：false</span><br><span class="line"></span><br><span class="line">              </span><br><span class="line"></span><br><span class="line">          - 严格检查</span><br><span class="line"></span><br><span class="line">            - strict</span><br><span class="line">              - 启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查</span><br><span class="line">            - alwaysStrict</span><br><span class="line">              - 总是以严格模式对代码进行编译</span><br><span class="line">            - noImplicitAny</span><br><span class="line">              - 禁止隐式的any类型</span><br><span class="line">            - noImplicitThis</span><br><span class="line">              - 禁止类型不明确的this</span><br><span class="line">            - strictBindCallApply</span><br><span class="line">              - 严格检查bind、call和apply的参数列表</span><br><span class="line">            - strictFunctionTypes</span><br><span class="line">              - 严格检查函数的类型</span><br><span class="line">            - strictNullChecks</span><br><span class="line">              - 严格的空值检查</span><br><span class="line">            - strictPropertyInitialization</span><br><span class="line">              - 严格检查属性是否初始化</span><br><span class="line"></span><br><span class="line">          - 额外检查</span><br><span class="line"></span><br><span class="line">            - noFallthroughCasesInSwitch</span><br><span class="line">              - 检查switch语句包含正确的break</span><br><span class="line">            - noImplicitReturns</span><br><span class="line">              - 检查函数没有隐式的返回值</span><br><span class="line">            - noUnusedLocals</span><br><span class="line">              - 检查未使用的局部变量</span><br><span class="line">            - noUnusedParameters</span><br><span class="line">              - 检查未使用的参数</span><br><span class="line"></span><br><span class="line">          - 高级</span><br><span class="line"></span><br><span class="line">            - allowUnreachableCode</span><br><span class="line">              - 检查不可达代码</span><br><span class="line">              - 可选值：</span><br><span class="line">                - true，忽略不可达代码</span><br><span class="line">                - false，不可达代码将引起错误</span><br><span class="line">            - noEmitOnError</span><br><span class="line">              - 有错误的情况下不进行编译</span><br><span class="line">              - 默认值：false</span><br><span class="line"></span><br><span class="line">## 4、webpack</span><br><span class="line"></span><br><span class="line">- 通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。</span><br><span class="line"></span><br><span class="line">- 步骤：</span><br><span class="line"></span><br><span class="line">  1. 初始化项目</span><br><span class="line"></span><br><span class="line">     - 进入项目根目录，执行命令 ``` npm init -y```</span><br><span class="line">       - 主要作用：创建package.json文件</span><br><span class="line"></span><br><span class="line">  2. 下载构建工具</span><br><span class="line"></span><br><span class="line">     - ```npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin```</span><br><span class="line">       - 共安装了7个包</span><br><span class="line">         - webpack</span><br><span class="line">           - 构建工具webpack</span><br><span class="line">         - webpack-cli</span><br><span class="line">           - webpack的命令行工具</span><br><span class="line">         - webpack-dev-server</span><br><span class="line">           - webpack的开发服务器</span><br><span class="line">         - typescript</span><br><span class="line">           - ts编译器</span><br><span class="line">         - ts-loader</span><br><span class="line">           - ts加载器，用于在webpack中编译ts文件</span><br><span class="line">         - html-webpack-plugin</span><br><span class="line">           - webpack中html插件，用来自动创建html文件</span><br><span class="line">         - clean-webpack-plugin</span><br><span class="line">           - webpack中的清除插件，每次构建都会先清除目录</span><br><span class="line"></span><br><span class="line">  3. 根目录下创建webpack的配置文件webpack.config.js</span><br><span class="line"></span><br><span class="line">     - ```javascript</span><br><span class="line">       const path = require(&quot;path&quot;);</span><br><span class="line">       const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);</span><br><span class="line">       const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);</span><br><span class="line">       </span><br><span class="line">       module.exports = &#123;</span><br><span class="line">           optimization:&#123;</span><br><span class="line">               minimize: false // 关闭代码压缩，可选</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           entry: &quot;./src/index.ts&quot;,</span><br><span class="line">           </span><br><span class="line">           devtool: &quot;inline-source-map&quot;,</span><br><span class="line">           </span><br><span class="line">           devServer: &#123;</span><br><span class="line">               contentBase: &#x27;./dist&#x27;</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           output: &#123;</span><br><span class="line">               path: path.resolve(__dirname, &quot;dist&quot;),</span><br><span class="line">               filename: &quot;bundle.js&quot;,</span><br><span class="line">               environment: &#123;</span><br><span class="line">                   arrowFunction: false // 关闭webpack的箭头函数，可选</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           resolve: &#123;</span><br><span class="line">               extensions: [&quot;.ts&quot;, &quot;.js&quot;]</span><br><span class="line">           &#125;,</span><br><span class="line">           </span><br><span class="line">           module: &#123;</span><br><span class="line">               rules: [</span><br><span class="line">                   &#123;</span><br><span class="line">                       test: /\.ts$/,</span><br><span class="line">                       use: &#123;</span><br><span class="line">                          loader: &quot;ts-loader&quot;     </span><br><span class="line">                       &#125;,</span><br><span class="line">                       exclude: /node_modules/</span><br><span class="line">                   &#125;</span><br><span class="line">               ]</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           plugins: [</span><br><span class="line">               new CleanWebpackPlugin(),</span><br><span class="line">               new HtmlWebpackPlugin(&#123;</span><br><span class="line">                   title:&#x27;TS测试&#x27;</span><br><span class="line">               &#125;),</span><br><span class="line">           ]</span><br><span class="line">       </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li><p>根目录下创建tsconfig.json，配置可以根据自己需要</p>
<ul>
<li>&#96;&#96;&#96;json<br>{<br>“compilerOptions”: {<br>    “target”: “ES2015”,<br>    “module”: “ES2015”,<br>    “strict”: true<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. 修改package.json添加如下配置</span><br><span class="line"></span><br><span class="line">   - ```json</span><br><span class="line">     &#123;</span><br><span class="line">       ...略...</span><br><span class="line">       &quot;scripts&quot;: &#123;</span><br><span class="line">         &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">         &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">         &quot;start&quot;: &quot;webpack serve --open chrome.exe&quot;</span><br><span class="line">       &#125;,</span><br><span class="line">       ...略...</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在src下创建ts文件，并在并命令行执行<code>npm run build</code>对代码进行编译，或者执行<code>npm start</code>来启动开发服务器</p>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>React-Tookit</title>
    <url>/2020/09/29/Tookit/</url>
    <content><![CDATA[<h1 id="React-Tookit"><a href="#React-Tookit" class="headerlink" title="React Tookit"></a>React Tookit</h1><blockquote>
<p>首先，React Tookit是React新提出的类Redux状态管理模式。该技术的提出是为了解决Redux的三个常见问题：</p>
<ul>
<li>🤨”配置Redux储存太复杂了“</li>
<li>🤔”必须添加很多包才能让Redux做任何有用的事情“</li>
<li>😯”Redux需要太多样板代码“</li>
</ul>
</blockquote>
<span id="more"></span>
<p><strong>更多介绍可以看<a href="https://redux-toolkit.js.org/introduction/getting-started">官方文档</a></strong></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官方提供了基于 React+Js 或者 React+Ts 的模块（脚手架）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Redux + Plain JS template</span><br><span class="line">npx create-react-app my-app --template redux</span><br><span class="line"></span><br><span class="line"># Redux + TypeScript template</span><br><span class="line">npx create-react-app my-app --template redux-typescript</span><br></pre></td></tr></table></figure>

<p>如果你想在已有的项目上安装，使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># NPM</span><br><span class="line">npm install @reduxjs/toolkit</span><br><span class="line">or</span><br><span class="line"># Yarn</span><br><span class="line">yarn add @reduxjs/toolkit</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然有你需要先有react-redux</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote>
<p>官方的例子是一个加减demo，我这里是一个购物车的案例</p>
</blockquote>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install @reduxjs/toolkit react-redux</span><br></pre></td></tr></table></figure>

<h3 id="创建Redux-Tookit"><a href="#创建Redux-Tookit" class="headerlink" title="创建Redux-Tookit"></a>创建Redux-Tookit</h3><p>一个项目仅有一个state，和redux一样，也是需要将各个分开的状态统一整合管理</p>
<p>注意：<code>counterSlice</code>和<code>shopCarList</code>是用户自定义的<code>slices</code>，在redux中称之为<code>reducer</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> counterSlice <span class="keyword">from</span> <span class="string">&#x27;./slices/slices_shoplist&#x27;</span>; <span class="comment">// 商品列表state</span></span><br><span class="line"><span class="keyword">import</span> shopCarList <span class="keyword">from</span> <span class="string">&quot;./slices/slices_shopCar&quot;</span>; <span class="comment">// 购物车state</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">configureStore</span>(&#123;</span><br><span class="line">    <span class="attr">reducer</span>:&#123;</span><br><span class="line">        <span class="attr">counter</span>:counterSlice, <span class="comment">// 配置多个slices</span></span><br><span class="line">        <span class="attr">shopCar</span>:shopCarList <span class="comment">// 更多slices</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">RooState</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> store.<span class="property">getState</span>&gt;  <span class="comment">// 类型生成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">AppDispatch</span> = <span class="keyword">typeof</span> store.<span class="property">dispatch</span>  <span class="comment">// 类型生成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>在<code>index.ts</code>文件中引入<code>&lt;Provider&gt;</code>组件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>; <span class="comment">// 引入第三方监视组件，用于传入state</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./redux/store&#x27;</span>; <span class="comment">// 引入公共state</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>) <span class="keyword">as</span> <span class="title class_">HTMLElement</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包裹App组件</span></span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>创建各个状态文件在<code>redux/slices/slices_shoplist</code></p>
<p>ts类型注解不做过多解释,<code>PayloadAction</code>是官方提供的TS接口,&lt;&gt;中注解使用该reducer传入参数的类型</p>
<blockquote>
<p>每个reducer方法都有形参<code>state,action</code>，<code>state</code>指向状态，<code>action</code>中的<code>action.payload</code>代表调用该reducer方法的时候传入的参数</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSlice,createAsyncThunk,<span class="title class_">PayloadAction</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> initArr &#123;</span><br><span class="line">    <span class="attr">key</span>:<span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">title</span>:<span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">price</span>:<span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">quantity</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> initType &#123;</span><br><span class="line">    <span class="attr">shopList</span>:<span class="title class_">Array</span>&lt;initArr&gt;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始状态</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">initial</span>:<span class="title class_">Array</span>&lt;initArr&gt; = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">key</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="attr">title</span>:<span class="string">&#x27;测试文本01&#x27;</span>,</span><br><span class="line">        <span class="attr">price</span>:<span class="number">100</span>,</span><br><span class="line">        <span class="attr">quantity</span>:<span class="number">100</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">key</span>:<span class="number">2</span>,</span><br><span class="line">        <span class="attr">title</span>:<span class="string">&#x27;测试文本02&#x27;</span>,</span><br><span class="line">        <span class="attr">price</span>:<span class="number">200</span>,</span><br><span class="line">        <span class="attr">quantity</span>:<span class="number">100</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">key</span>:<span class="number">3</span>,</span><br><span class="line">        <span class="attr">title</span>:<span class="string">&#x27;测试文本03&#x27;</span>,</span><br><span class="line">        <span class="attr">price</span>:<span class="number">300</span>,</span><br><span class="line">        <span class="attr">quantity</span>:<span class="number">100</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">initialState</span>:initType = &#123;</span><br><span class="line">    <span class="attr">shopList</span>:initial</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counterSlice = <span class="title function_">createSlice</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;counter&#x27;</span>,</span><br><span class="line">    initialState, <span class="comment">// 初始状态</span></span><br><span class="line">    <span class="attr">reducers</span>:&#123; <span class="comment">// reducer</span></span><br><span class="line">        <span class="attr">addShop</span>:<span class="function">(<span class="params">state,action:PayloadAction&lt;initArr&gt;</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 添加商品功能</span></span><br><span class="line">            state.<span class="property">shopList</span>.<span class="title function_">push</span>(action.<span class="property">payload</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">deleShop</span>:<span class="function">(<span class="params">state,action:PayloadAction&lt;<span class="built_in">number</span>&gt;</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 删除指定商品功能</span></span><br><span class="line">            state.<span class="property">shopList</span> = state.<span class="property">shopList</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">tit:initArr</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> tit.<span class="property">key</span> !== action.<span class="property">payload</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123;</span><br><span class="line">    addShop,   <span class="comment">// 将各个reducer暴露出去</span></span><br><span class="line">    deleShop</span><br><span class="line">&#125; = counterSlice.<span class="property">actions</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterSlice.<span class="property">reducer</span>;</span><br></pre></td></tr></table></figure>

<p>在组件中使用，在函数组件中使用钩子<code>useSelector,useDispatch</code>获取初始状态以及dispatch，代码过多请仅关注标注部分</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useSelector,useDispatch&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>  <span class="comment">// 引入两个必要的钩子</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">RooState</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../../redux/store&#x27;</span>; <span class="comment">// 引入生成的类型注解</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;styled-components&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; addShop &#125; <span class="keyword">from</span> <span class="string">&#x27;../../redux/slices/slices_shoplist&#x27;</span>; <span class="comment">// 引入使用的reducer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">OneDiv</span> = styled.<span class="property">div</span><span class="string">`</span></span><br><span class="line"><span class="string">  h1&#123;</span></span><br><span class="line"><span class="string">    font-size:25px;</span></span><br><span class="line"><span class="string">    font-weight:600;</span></span><br><span class="line"><span class="string">    color:#5592fa;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Input</span> = styled.<span class="property">input</span><span class="string">`</span></span><br><span class="line"><span class="string">  border:1px solid #5592fa;</span></span><br><span class="line"><span class="string">  border-radius:5px;</span></span><br><span class="line"><span class="string">  width: <span class="subst">$&#123;(props)=&gt;props.width&#125;</span>;</span></span><br><span class="line"><span class="string">  height: 30px;</span></span><br><span class="line"><span class="string">  margin-top:20px;</span></span><br><span class="line"><span class="string">  font-size:18px;</span></span><br><span class="line"><span class="string">  padding-left:10px;</span></span><br><span class="line"><span class="string">  outline:none;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Span</span> = styled.<span class="property">span</span><span class="string">`</span></span><br><span class="line"><span class="string">  color:#5592fa;</span></span><br><span class="line"><span class="string">  padding: 0px 9px;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Button</span> = styled.<span class="property">button</span><span class="string">`</span></span><br><span class="line"><span class="string">  width:100px;</span></span><br><span class="line"><span class="string">  height: 30px;</span></span><br><span class="line"><span class="string">  background-color:#5592fa;</span></span><br><span class="line"><span class="string">  color:#fff;</span></span><br><span class="line"><span class="string">  padding: 0px 9px;</span></span><br><span class="line"><span class="string">  border:none;</span></span><br><span class="line"><span class="string">  cursor: pointer;</span></span><br><span class="line"><span class="string">  margin:30px 0px 0px 80px;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">One</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> shopTitle = useRef&lt;<span class="title class_">HTMLInputElement</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> shopPrice = useRef&lt;<span class="title class_">HTMLInputElement</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> shopQuantity = useRef&lt;<span class="title class_">HTMLInputElement</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 获取状态(注意RooState类型就是store中生成的类型)</span></span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">ULS</span> = <span class="title function_">useSelector</span>(<span class="function">(<span class="params">state:RooState</span>)=&gt;</span>state.<span class="property">counter</span>); </span><br><span class="line">  <span class="comment">// 生成dispatch</span></span><br><span class="line">  <span class="keyword">const</span>  dispatch = <span class="title function_">useDispatch</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">addShopList</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (shopTitle.<span class="property">current</span>?.<span class="property">value</span>.<span class="title function_">trim</span>()&amp;&amp;shopPrice.<span class="property">current</span>?.<span class="property">value</span>.<span class="title function_">trim</span>()&amp;&amp;shopQuantity.<span class="property">current</span>?.<span class="property">value</span>.<span class="title function_">trim</span>()) &#123;      </span><br><span class="line">      <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        <span class="attr">key</span>:+<span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">        <span class="attr">title</span>:shopTitle.<span class="property">current</span>?.<span class="property">value</span>,</span><br><span class="line">        <span class="attr">price</span>:<span class="built_in">parseInt</span>(shopPrice.<span class="property">current</span>?.<span class="property">value</span>),</span><br><span class="line">        <span class="attr">quantity</span>:<span class="built_in">parseInt</span>(shopQuantity.<span class="property">current</span>?.<span class="property">value</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">dispatch</span>(<span class="title function_">addShop</span>(obj)) <span class="comment">// 调用方法</span></span><br><span class="line">      shopTitle.<span class="property">current</span>.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      shopPrice.<span class="property">current</span>.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      shopQuantity.<span class="property">current</span>.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;请输入内容&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">OneDiv</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>添加商品<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Span</span>&gt;</span>商品名称:<span class="tag">&lt;/<span class="name">Span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400px&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;shopTitle&#125;</span> <span class="attr">placeholder</span>=<span class="string">&quot;名称&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Span</span>&gt;</span>商品价格:<span class="tag">&lt;/<span class="name">Span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50px&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;shopPrice&#125;</span> <span class="attr">placeholder</span>=<span class="string">&quot;价格&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Span</span>&gt;</span>商品数量:<span class="tag">&lt;/<span class="name">Span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50px&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;shopQuantity&#125;</span> <span class="attr">placeholder</span>=<span class="string">&quot;数量&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>addShopList()&#125;&gt;添加商品<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">OneDiv</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">One</span></span><br></pre></td></tr></table></figure>

<h3 id="关于异步"><a href="#关于异步" class="headerlink" title="关于异步"></a>关于异步</h3><blockquote>
<p>官方提供的Demo中的异步属于简化写法，并不会对异步进行监听</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">incrementAsync</span> = (<span class="params">amount</span>) =&gt; <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 异步方法存放于此</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">dispatch</span>(<span class="title function_">incrementByAmount</span>(amount)) <span class="comment">// 可在此调用同步中的reducer方法</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种写法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSlice,createAsyncThunk &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> loadPic = <span class="title function_">createAsyncThunk</span>(<span class="string">&#x27;weather/loadPic&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve:(str:<span class="built_in">string</span>)=&gt;<span class="built_in">void</span>,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;数据&#x27;</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;) <span class="comment">// 此处的返回结果会在 .fulfilled中作为payload的值</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counterSlice = <span class="title function_">createSlice</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;counter&#x27;</span>,</span><br><span class="line">    <span class="attr">initialState</span>:&#123;</span><br><span class="line">        <span class="attr">value</span>:<span class="number">0</span> <span class="comment">// 初始值</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">reducers</span>:&#123; <span class="comment">// reducer</span></span><br><span class="line">        <span class="attr">incremented</span>:<span class="function">(<span class="params">state</span>)=&gt;</span>&#123;</span><br><span class="line">            state.<span class="property">value</span>+=<span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">decremented</span>:<span class="function">(<span class="params">state</span>)=&gt;</span>&#123;</span><br><span class="line">            state.<span class="property">value</span>-=<span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">add</span>:<span class="function">(<span class="params">state,action</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// action的playload是调用该函数的时候传入的值</span></span><br><span class="line">            state.<span class="property">value</span>+=action.<span class="property">payload</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 第一种写法</span></span><br><span class="line">    <span class="comment">// extraReducers:&#123;</span></span><br><span class="line">    <span class="comment">//     [loadPic.pending.type](state,action:any)&#123;</span></span><br><span class="line">    <span class="comment">//         console.log(&#x27;pending&#x27;,state,action);</span></span><br><span class="line">    <span class="comment">//     &#125;,</span></span><br><span class="line">    <span class="comment">//     [loadPic.fulfilled.type](state,action:any)&#123;</span></span><br><span class="line">    <span class="comment">//         console.log(&#x27;fulfilled&#x27;,state,action);</span></span><br><span class="line">    <span class="comment">//         state.value+=1;</span></span><br><span class="line">    <span class="comment">//     &#125;,</span></span><br><span class="line">    <span class="comment">//     [loadPic.rejected.type](state,action:any)&#123;</span></span><br><span class="line">    <span class="comment">//         console.log(&#x27;rejected&#x27;,state,action);</span></span><br><span class="line">    <span class="comment">//     &#125;,</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 第二种写法</span></span><br><span class="line">    <span class="title function_">extraReducers</span>(<span class="params">builder</span>)&#123;</span><br><span class="line">        builder</span><br><span class="line">            .<span class="title function_">addCase</span>(loadPic.<span class="property">pending</span>,<span class="function">(<span class="params">state</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(state);</span><br><span class="line">            &#125;)</span><br><span class="line">            .<span class="title function_">addCase</span>(loadPic.<span class="property">fulfilled</span>,<span class="function">(<span class="params">state</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(state);</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123;incremented,decremented,add&#125; = counterSlice.<span class="property">actions</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterSlice.<span class="property">reducer</span>;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>框架</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM diff</title>
    <url>/2020/10/11/diff/</url>
    <content><![CDATA[<p>DOM diff 作为工程问题，需要具有一定算法思维，因此经常出现在面试场景中，毕竟这是难得出现在工程领域的算法问题。</p>
<p>无论出于面试目的，还是深入学习目的，都有必要将这个问题搞懂，因此前端精读我们就专门用一个章节说清楚此问题。</p>
<span id="more"></span>

<h2 id="精读"><a href="#精读" class="headerlink" title="精读"></a>精读</h2><p>Dom diff 是所有现在框架必须做的事情，这背后的原因是，由 Jquery 时代的面向操作过程转变为数据驱动视图导致的。</p>
<p>为什么 Jquery 时代不需要 Dom diff？因为 Dom diff 交给业务处理了，我们调用 <code>.append</code> 或者 <code>.move</code> 之类 Dom 操作函数，就是显式申明了如何做 Dom diff，这种方案是最高效的，因为怎么移动 Dom 只有业务最清楚。</p>
<p>但这样的问题也很明显，就是业务心智负担太重，对于复杂系统，需要做 Dom diff 的地方太多，不仅写起来繁琐，当状态存在交错时，面向过程的手动 Dom diff 容易出现状态遗漏，导致边界错误，就算你没有写出 bug，代码的可维护性也绝对算不上好。</p>
<p>解决方案就是数据驱动，我们只需要关注数据如何映射到 UI，这样无论业务逻辑再复杂，我们永远只需要解决局部状态的映射，这极大降低了复杂系统的维护复杂度，以前需要一个老手写的逻辑，现在新手就能做了，这是非常了不起的变化。</p>
<p>但有利也有弊，这背后 Dom diff 就要交给框架来做了，所以是否能高效的做 Dom diff，是一个数据驱动框架能否应用于生产环境的重要指标，接下来，我们来看看 Dom diff 是如何做的吧。</p>
<h3 id="理想的-Dom-diff"><a href="#理想的-Dom-diff" class="headerlink" title="理想的 Dom diff"></a>理想的 Dom diff</h3><img width=600 src="https://img.alicdn.com/imgextra/i4/O1CN01wmLt541W6xt9a1BPm_!!6000000002740-2-tps-1112-814.png">

<p>如图所示，理想的 Dom diff 自然是滴水不漏的复用所有能复用的，实在遇到新增或删除时，才执行插入或删除。这样的操作最贴近 Jquery 时代我们手写的 Dom diff 性能。</p>
<p>可惜程序无法猜到你的想法，想要精确复用就必须付出高昂的代价：时间复杂度 O(n³) 的 diff 算法，这显然是无法接受的，因此理想的 Dom diff 算法无法被使用。</p>
<blockquote>
<p>关于 O(n³) 的由来。由于左树中任意节点都可能出现在右树，所以必须在对左树深度遍历的同时，对右树进行深度遍历，找到每个节点的对应关系，这里的时间复杂度是 O(n²)，之后需要对树的各节点进行增删移的操作，这个过程简单可以理解为加了一层遍历循环，因此再乘一个 n。</p>
</blockquote>
<h3 id="简化的-Dom-diff"><a href="#简化的-Dom-diff" class="headerlink" title="简化的 Dom diff"></a>简化的 Dom diff</h3><img width=700 src="https://img.alicdn.com/imgextra/i3/O1CN01SNNr8d1EvedrTG4eN_!!6000000000414-2-tps-1252-800.png">

<p>如图所示，只按层比较，就可以将时间复杂度降低为 O(n)。按层比较也不是广度遍历，其实就是判断某个节点的子元素间 diff，跨父节点的兄弟节点也不必比较。</p>
<p>这样做确实非常高效，但代价就是，判断的有点傻，比如 ac 明明是一个移动操作，却被误识别为删除 + 新增。</p>
<p>好在跨 DOM 复用在实际业务场景中很少出现，因此这种笨拙出现的频率实际上非常低，这时候我们就不要太追求学术思维上的严谨了，毕竟框架是给实际项目用的，实际项目中很少出现的场景，算法是可以不考虑的。</p>
<p>下面是同层 diff 可能出现的三种情况，非常简单，看图即可：</p>
<img width=700 src="https://img.alicdn.com/imgextra/i2/O1CN016XhiF01H2BWRGocp8_!!6000000000699-2-tps-1232-1380.png">

<p>那么同层比较是怎么达到 O(n) 时间复杂度的呢？我们来看具体框架的思路。</p>
<h3 id="React-的-Dom-diff"><a href="#React-的-Dom-diff" class="headerlink" title="React 的 Dom diff"></a>React 的 Dom diff</h3><img width=500 src="https://img.alicdn.com/imgextra/i4/O1CN01YBUnOF28fjM4qW4v9_!!6000000007960-2-tps-882-158.png">

<p>假设这么一种情况，我们将 a 移到了 c 后，那么框架从最终状态倒推，如何最快的找到这个动机呢？React 采用了 <strong>仅右移策略</strong>，即对元素发生的位置变化，只会将其移动到右边，那么右边移完了，其他位置也就有序了。</p>
<p>我们看图说明：</p>
<img width=500 src="https://img.alicdn.com/imgextra/i4/O1CN01EeRPFd1Rnwz7WUpiC_!!6000000002157-2-tps-1002-610.png">

<p>遍历 Old 存储 Map 和 Vue 是一样的，然后就到了第二步遍历 New，<code>b</code> 下标从原来的 <code>1</code> 变成了 <code>0</code>，需要左移才行，但我们不左移，我们只右移，因为所有右移做完后，左移就等于自动做掉了（前面的元素右移后，自己自然被顶到前面去了，实现了左移的效果）。</p>
<img width=500 src="https://img.alicdn.com/imgextra/i4/O1CN01kRDF2P1ErX4vjTkGq_!!6000000000405-2-tps-998-412.png">

<p>同理，c 下标从 <code>2</code> 变成了 <code>1</code>，需要左移才行，但我们继续不动。</p>
<img width=500 src="https://img.alicdn.com/imgextra/i3/O1CN01zsDAtY1DmCrAAag0f_!!6000000000258-2-tps-978-418.png">

<p>a 的下标从 <code>0</code> 变成 <code>2</code>，终于可以右移了！</p>
<img width=500 src="https://img.alicdn.com/imgextra/i1/O1CN01LCmhdG1TDQdQKEx2E_!!6000000002348-2-tps-980-488.png">

<p>后面的 d、e 下标没变，就不用动。我们纵观整体可以发现，b 和 c 因为前面的 a 被抽走了，自然发生了左移。这就是用一个右移代替两个左移的高效操作。</p>
<p>同时我们发现，这也确实找到了我们开始提到的最佳位移策略。</p>
<p>那这个算法真的有这么聪明吗？显然不是，这个算法只是歪打误撞碰对了而已，<strong>有用右移替代左移的算法，就有用左移替代右移的算法</strong>，既然选择了右移替代左移，那么一定丢失了左移代替右移的效率。</p>
<p>什么时候用左移代替右移效率最高？就是把数组最后一位移到第一位的场景：</p>
<img width=500 src="https://img.alicdn.com/imgextra/i2/O1CN01kAkNxD1YAHzyOTg7I_!!6000000003018-2-tps-904-144.png">

<p>显然左移只要一步，那么右移就是 n-1 步，在这个例子就是 4 步，我们看右移算法图解：</p>
<img width=500 src="https://img.alicdn.com/imgextra/i2/O1CN01UNjJcv1m64yfQz6wS_!!6000000004904-2-tps-974-400.png">

<p>首先找到 e，位置从 <code>4</code> 变成了 <code>0</code>，但我们不能左移！所以只能保持不动，悲剧从此开始。</p>
<img width=800 src="https://img.alicdn.com/imgextra/i3/O1CN01xmOwVd1TJqB2Hakpk_!!6000000002362-2-tps-1696-374.png">

<p>虽然算法已经不是最优了，但该做的还是要做，其实之前有一个 lastIndex 概念没有说，因为 e 已经在 <code>4</code> 的位置了，所以再把 a 从 <code>0</code> 挪到 <code>1</code> 已经不够了，此时 a 应该从 <code>0</code> 挪到 <code>5</code>。</p>
<p>方法就是记录 <code>lastIndex = max(oldIndex, newIndex)</code> &#x3D;&gt; <code>lastIndex = max(4, 0)</code>，下一次移动到 <code>lastIndex + 1</code> 也就是 <code>5</code>：</p>
<img width=800 src="https://img.alicdn.com/imgextra/i2/O1CN01ylI1wb1FrowPwcROD_!!6000000000541-2-tps-1704-376.png">

<p>发现 a 从 <code>0</code> 变成了 <code>5</code>（注意，此时考虑到 lastIndex 因素），所以右移。</p>
<img width=800 src="https://img.alicdn.com/imgextra/i3/O1CN01UZ2Wf71SxrAQfLZ48_!!6000000002314-2-tps-1704-378.png">

<p>同理，b、c、d 也一样。我们最后发现，发生了 4 次右移，e 也因为自然左移了 4 次到达了首位，符合预期。</p>
<p>所以这是一个有利有弊的算法。新增和删除比较简单，和 Vue 差不多。</p>
<p>PS：最新版 React Dom diff 算法如有更新，欢迎在评论区指出，因为这种算法看来不如 Vue 的高效。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Dom diff 总结有这么几点考虑：</p>
<ol>
<li>完全对比 O(n³) 无法接受，故降级为同层对比的 O(n) 方案。</li>
<li>为什么降级可行？因为跨层级很少发生，可以忽略。</li>
<li>同层级也不简单，难点是如何高效位移，即最小步数完成位移。</li>
<li>Vue 为了尽量不移动，先左右夹击跳过不变的，再找到最长连续子串保持不动，移动其他元素。</li>
<li>React 采用仅右移方案，在大部分从左往右移的业务场景中，得到了较好的性能。</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>es6</tag>
        <tag>diff</tag>
      </tags>
  </entry>
  <entry>
    <title>fetch/async/await</title>
    <url>/2022/08/11/fetch/</url>
    <content><![CDATA[<h2 id="fetch和await的结合"><a href="#fetch和await的结合" class="headerlink" title="fetch和await的结合"></a>fetch和await的结合</h2><p>起因是在写一个React发送ajax请求的案例中，遇到了一个关于fetch发送请求的问题，直接上代码:</p>
<blockquote>
<p>使用fetch发送请求后在第一个.then之前的<code>fetch(https:xxxx//$&#123;value&#125;)</code>返回的是一个promise实例对象，所以它的后面可以跟.then，但是这个.then中触发的成功回调或者失败回调仅仅是判断这个请求是否连接到服务器，并不会返回服务器发送回来的数据。</p>
<p>要想得到数据就需要调用res原型上的方法<code>res.json()</code>得到一个新的promise，并且return出去，紧跟后面的.then就可以采用链式.then的方法再次获得成功的回调(服务器返回的数据在里面)。</p>
</blockquote>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  search = <span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="comment">// 使用fetch发送网络请求(未优化版本)</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">`https://api.github.com/search/users?q=<span class="subst">$&#123;value&#125;</span>`</span>).<span class="title function_">then</span>(</span><br><span class="line">      <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;联系服务器成功&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">json</span>();</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// error=&gt;&#123;</span></span><br><span class="line">      <span class="comment">//   console.log(&#x27;联系服务器失败&#x27;);</span></span><br><span class="line">      <span class="comment">//   // 如果第一个then没有返回值，那么它会返回一个undefined，</span></span><br><span class="line">      <span class="comment">//   // 而undefined所在的.then返回的promise则是一个成功状态的promise</span></span><br><span class="line">      <span class="comment">//   // 使用return new Promise();返回一个初始状态的Promise实例，则下面的then则不会走了</span></span><br><span class="line">      <span class="comment">//   return new Promise();</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">    ).<span class="title function_">then</span>(</span><br><span class="line">      <span class="function"><span class="params">ress</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// console.log(ress.items);</span></span><br><span class="line">        <span class="title class_">PubSub</span>.<span class="title function_">publish</span>(<span class="string">&#x27;change&#x27;</span>,&#123;<span class="attr">isFirst</span>:<span class="literal">false</span>,<span class="attr">users</span>:ress.<span class="property">items</span>,<span class="attr">isLoading</span>:<span class="literal">false</span>&#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// error=&gt;&#123;</span></span><br><span class="line">      <span class="comment">//   console.log(&#x27;获取数据失败&#x27;);</span></span><br><span class="line">      <span class="comment">//   PubSub.publish(&#x27;change&#x27;,&#123;isFirst:false,err:error.message&#125;)</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">    ).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然可以不用每个.then都捕获错误回调，可以在结尾统一拦截错误使用<code>.catch()</code></p>
</blockquote>
<p>还有一个小bug就是，如果在第一个.then中的错误回调没有返回一个promise或者其他什么的，他会默认返回undefined，而这个undefined则代表其所在.then返回的是一个成功状态的promise，这就导致后面的.then执行的是成功回调。</p>
<hr>
<p><strong>然后再说说async和await优化版本：</strong></p>
<blockquote>
<p>使用async和await可以更大限度优化代码，</p>
<p>等待<code>fetch(https://api.github.com/search/users?q=$&#123;value&#125;)</code>返回一个成功态promise给response，response接收到后调用它原型上的方法<code>response.json()</code>当然也要等待它返回一个成功态promise，并将其赋值给data，此时的data就是<strong>服务器返回的真正数据</strong></p>
<p>另外，捕获错误可以使用try-catch捕获错误</p>
<p>这种写法可以使用同步执行的思考来看待这个请求，对于promise的理解更深一步加强</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">search = <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="comment">// 解构赋值的连续写法</span></span><br><span class="line">    <span class="comment">// keyWordElement是未被定义的</span></span><br><span class="line">    <span class="keyword">const</span> &#123;<span class="attr">keyWordElement</span>:&#123;value&#125;&#125;=<span class="variable language_">this</span></span><br><span class="line">    <span class="comment">// 发送请求前通知List更新状态</span></span><br><span class="line">    <span class="title class_">PubSub</span>.<span class="title function_">publish</span>(<span class="string">&#x27;change&#x27;</span>,&#123;<span class="attr">isFirst</span>:<span class="literal">false</span>,<span class="attr">isLoading</span>:<span class="literal">true</span>&#125;)<span class="comment">//不用关注</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`https://api.github.com/search/users?q=<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">      <span class="comment">// console.log(data);//服务器返回的真正数据</span></span><br><span class="line">      <span class="title class_">PubSub</span>.<span class="title function_">publish</span>(<span class="string">&#x27;change&#x27;</span>,&#123;<span class="attr">isFirst</span>:<span class="literal">false</span>,<span class="attr">users</span>:data.<span class="property">items</span>,<span class="attr">isLoading</span>:<span class="literal">false</span>&#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求出错&#x27;</span>,error);</span><br><span class="line">      <span class="title class_">PubSub</span>.<span class="title function_">publish</span>(<span class="string">&#x27;change&#x27;</span>,&#123;<span class="attr">isFirst</span>:<span class="literal">false</span>,<span class="attr">err</span>:error.<span class="property">message</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>es6</tag>
        <tag>fetch</tag>
        <tag>async/await</tag>
      </tags>
  </entry>
  <entry>
    <title>scss</title>
    <url>/2022/10/11/scss/</url>
    <content><![CDATA[<h1 id="scss快速入门："><a href="#scss快速入门：" class="headerlink" title="scss快速入门："></a>scss快速入门：</h1><br>

<hr>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>写在最前面：在认识之前需要安装下sass；在这里我是在react脚手架中安装运行，在其他环境中可能安装方式不同，还有可能需要配置；但是不影响对scss语法的介绍使用。</p>
<p>scss需要经过编译为css才能被浏览器识别，我这里只做一个小demo，直接使用react脚手架进行编译。</p>
<p>首先安装node-scss:</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i node-sass -v </span><br><span class="line">yarn add node-sass -v</span><br></pre></td></tr></table></figure>

<br>

<h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><h3 id="1-变量使用"><a href="#1-变量使用" class="headerlink" title="1.变量使用"></a>1.变量使用</h3><p>SCSS中的变量以$开头。</p>
<p><strong>scss变量</strong>类似JS语法，可分为:</p>
<ul>
<li>全局变量    —- 在大括号之外声明的变量</li>
<li>局部变量    —- 在括号中之内声明的变量</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">$<span class="attribute">border-color</span>:<span class="number">#aaa</span>; //声明变量  全局</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">$<span class="attribute">border-width</span>:<span class="number">1px</span>;  // 声明变量 局部</span><br><span class="line">    <span class="attribute">border</span>:$border-width solid $border-color; //使用变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后的CSS</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#aaa</span>; //使用变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以把SCSS看做一个模板引擎，编译的过程中用变量的值去替代变量所占据的位置。</p>
<p>注意：SCSS中变量名使用中划线或下划线都是指向同一变量的，上文中定义了一个变量$border-color，这时再定义一个变量$border_color:#ccc,他们指向同一个变量，.container的值会被第二次定义的变量覆盖。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">$<span class="attribute">border-color</span>:<span class="number">#aaa</span>; //声明变量</span><br><span class="line">$border_color:<span class="number">#ccc</span>;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    $<span class="attribute">border-width</span>:<span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border</span>:$border-width solid $border-color; //使用变量</span><br><span class="line">&#125;</span><br><span class="line">编译后的CSS</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#ccc</span>; //使用变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中我们要知道</p>
<p>（1）变量名使用中划线或下划线都是指向同一变量的。</p>
<p>（2）后定义的变量声明会被忽略，但赋值会被执行，这一点和ES5中var声明变量是一样的。</p>
<h3 id="2-嵌套规则"><a href="#2-嵌套规则" class="headerlink" title="2.嵌套规则"></a>2.嵌套规则</h3><p>我们先来看一个例子。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css*/</span></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#aaa</span>;</span><br><span class="line">    <span class="attribute">list-style</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">ul</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span>&gt;<span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个让列表元素横向排列的例子，我们在这个例子中写了很多重复的代码，.container写了很多遍，下面我将用SCSS简写上面的例子。</p>
<h4 id="2-1嵌套选择器"><a href="#2-1嵌套选择器" class="headerlink" title="2.1嵌套选择器"></a>2.1嵌套选择器</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*scss*/</span></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#aaa</span>;</span><br><span class="line">    <span class="attribute">list-style</span>:none;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-tag">li</span> &#123;</span><br><span class="line">        <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-tag">li</span>&gt;<span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>:inline-block;</span><br><span class="line">        <span class="attribute">padding</span>:<span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">ul</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以将公共的父元素提取出来。</p>
<h4 id="2-2嵌套中的父级选择器-amp"><a href="#2-2嵌套中的父级选择器-amp" class="headerlink" title="2.2嵌套中的父级选择器**&amp;**"></a>2.2嵌套中的父级选择器**&amp;**</h4><p>SCSS提供了一个选择器可以选中当前元素的父元素，使用&amp;表示，下面用父级选择器继续简化代码。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*scss*/</span></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#aaa</span>;</span><br><span class="line">    <span class="attribute">list-style</span>:none;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-tag">li</span> &#123;</span><br><span class="line">        <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-tag">li</span>&gt;<span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>:inline-block;</span><br><span class="line">        <span class="attribute">padding</span>:<span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    // 只能在嵌套内部使用父级选择器</span><br><span class="line">    &amp;<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>:block;</span><br><span class="line">        <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="attribute">clear</span>:both;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3嵌套组合选择器"><a href="#2-3嵌套组合选择器" class="headerlink" title="2.3嵌套组合选择器"></a>2.3嵌套组合选择器</h4><p>在嵌套规则中可以写任何css代码，包括群组选择器（,），子代选择器（&gt;），同层相邻组合选择器（+）、同层全体组合选择器（~）等等，下面继续将自带选择器简化掉。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*scss*/</span></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#aaa</span>;</span><br><span class="line">    <span class="attribute">list-style</span>:none;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-tag">li</span> &#123;</span><br><span class="line">        <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">        </span><br><span class="line">        &gt;<span class="selector-tag">a</span> &#123;</span><br><span class="line">            <span class="attribute">display</span>:inline-block;</span><br><span class="line">            <span class="attribute">padding</span>:<span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &amp;<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>:block;</span><br><span class="line">        <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="attribute">clear</span>:both;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子代选择器可以写在外层选择器右边（如下述例子）也可以写在内层选择器左边（如上述例子）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span> &gt;&#123; </span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>:inline-block;</span><br><span class="line">        <span class="attribute">padding</span>:<span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-4嵌套属性"><a href="#2-4嵌套属性" class="headerlink" title="2.4嵌套属性"></a>2.4嵌套属性</h4><p>先看一个例子</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css*/</span></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#aaa</span>;</span><br><span class="line">    <span class="attribute">border-left</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-right</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中我们只需要两条边框，使用SCSS重写一遍。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*scss*/</span></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#aaa</span> &#123;</span><br><span class="line">        <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scss识别一个属性以分号结尾时则判断为一个属性，以大括号结尾时则判断为一个嵌套属性，规则是将外部的属性以及内部的属性通过中划线连接起来形成一个新的属性。</p>
<h3 id="3-导入SCSS文件"><a href="#3-导入SCSS文件" class="headerlink" title="3.导入SCSS文件"></a>3.导入SCSS文件</h3><p>大型项目中css文件往往不止一个，css提供了@import命令在css内部引入另一个css文件，浏览器只有在执行到@import语句后才会去加载对应的css文件，导致页面性能变差，故基本不使用。SCSS中的@import命令跟原生的不太一样，后续会讲解到。</p>
<h4 id="3-1导入变量的优先级问题-变量默认值"><a href="#3-1导入变量的优先级问题-变量默认值" class="headerlink" title="3.1导入变量的优先级问题-变量默认值"></a>3.1导入变量的优先级问题-变量默认值</h4><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*App1.scss*/</span></span><br><span class="line">$<span class="attribute">border-color</span>:<span class="number">#aaa</span>; <span class="comment">//声明变量</span></span><br><span class="line"><span class="keyword">@import</span> App2.scss;  <span class="comment">//引入另一个SCSS文件</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid $border-color; <span class="comment">//使用变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*App2.scss*/</span></span><br><span class="line">$<span class="attribute">border-color</span>:<span class="number">#ccc</span>; <span class="comment">//声明变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*生成的css文件*/</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#ccc</span>; <span class="comment">//使用变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可能并不是我们想要的，有时候我们希望引入的某些样式不更改原有的样式，这时我们可以使用变量默认值。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*App1.scss*/</span></span><br><span class="line">$<span class="attribute">border-color</span>:<span class="number">#aaa</span>; <span class="comment">//声明变量</span></span><br><span class="line"><span class="keyword">@import</span> App2.scss;  <span class="comment">//引入另一个SCSS文件</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid $border-color; <span class="comment">//使用变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*App2.scss*/</span></span><br><span class="line">$<span class="attribute">border-color</span>:<span class="number">#ccc</span> !default; <span class="comment">//声明变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*生成的css文件*/</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#aaa</span>; <span class="comment">//使用变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>导入的文件App2.scss只在文件中不存在$border-color时起作用，若App1.scss中已经存在了$border-color变量，则App2.scss中的$border-color不生效。</p>
<p>!default只能使用与变量中。</p>
<h4 id="3-2嵌套导入"><a href="#3-2嵌套导入" class="headerlink" title="3.2嵌套导入"></a>3.2嵌套导入</h4><p>上一个例子中我们是在全局中导入的App2.scss，现在我们在为App2.scss添加一些内容，并在局部中导入。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*App1.scss*/</span></span><br><span class="line">$<span class="attribute">border-color</span>:<span class="number">#aaa</span>; //声明变量</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="keyword">@import</span> App2.scss;  //引入另一个SCSS文件</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid $border-color; //使用变量</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*App2.scss*/</span></span><br><span class="line">$<span class="attribute">border-color</span>:<span class="number">#ccc</span> !default; //声明变量</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*生成的css文件*/</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#aaa</span>; //使用变量</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看得出来，就是将App2.scss中的所有内容直接写入到App1.scss的.container选择器中。</p>
<h4 id="3-3-使用原生-import"><a href="#3-3-使用原生-import" class="headerlink" title="3.3 使用原生@import"></a>3.3 使用原生@import</h4><p>前面我们说到基本不使用原生@import，但某些情况下我们不得不使用原生@import时了，SCSS也为我们处理了这种情况，直接导入css文件即可。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;App.css&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-注释"><a href="#4-注释" class="headerlink" title="4.注释"></a>4.注释</h3><p>SCSS中的注释有两种</p>
<p>（1）&#x2F;<em>注释</em>&#x2F;:这种注释会被保留到编译后的css文件中。</p>
<p>（2）&#x2F;&#x2F;注释:这种注释不会被保留到编译后生成的css文件中。</p>
<h3 id="5-混合器（函数）"><a href="#5-混合器（函数）" class="headerlink" title="5.混合器（函数）"></a>5.混合器（函数）</h3><h4 id="5-1声明一个函数"><a href="#5-1声明一个函数" class="headerlink" title="5.1声明一个函数"></a>5.1声明一个函数</h4><p>使用@mixin指令声明一个函数，看一下自己的css文件，有重复的代码片段都可以考虑使用混合器将他们提取出来复用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> border-radius&#123;</span><br><span class="line">    -moz-<span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    -webkit-<span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>混合器作用域内的属性都是return的值，除此之外，还可以为函数传参数。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> get-border-radius($border-radius,$<span class="attribute">color</span>)&#123;</span><br><span class="line">    -moz-<span class="attribute">border-radius</span>: $border-radius;</span><br><span class="line">    -webkit-<span class="attribute">border-radius</span>: $border-radius;</span><br><span class="line">    <span class="attribute">border-radius</span>: $border-radius;</span><br><span class="line">    <span class="attribute">color</span>:$color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以设置混合器的默认值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> get-border-radius($<span class="attribute">border-radius</span>:<span class="number">5px</span>,$<span class="attribute">color</span>:red)&#123;</span><br><span class="line">    -moz-<span class="attribute">border-radius</span>: $border-radius;</span><br><span class="line">    -webkit-<span class="attribute">border-radius</span>: $border-radius;</span><br><span class="line">    <span class="attribute">border-radius</span>: $border-radius;</span><br><span class="line">    <span class="attribute">color</span>:$color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2使用函数"><a href="#5-2使用函数" class="headerlink" title="5.2使用函数"></a>5.2使用函数</h4><p>使用函数的关键字为@include</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#aaa</span>;</span><br><span class="line">    <span class="variable">@include</span> get-border-radius;         <span class="comment">//不传参则为默认值5px</span></span><br><span class="line">    <span class="variable">@include</span> <span class="built_in">get-border-radius</span>(<span class="number">10px</span>,blue);   <span class="comment">//传参</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*多个参数时，传参指定参数的名字，可以不用考虑传入的顺序*/</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#aaa</span>;</span><br><span class="line">    <span class="variable">@include</span> get-border-radius;         <span class="comment">//不传参则为默认值5px</span></span><br><span class="line">    <span class="variable">@include</span> <span class="built_in">get-border-radius</span>($<span class="attribute">color</span>:blue,$<span class="attribute">border-radius</span>:<span class="number">10px</span>);   <span class="comment">//传参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可能会想到，直接将混合器写成一个class不就行了，但是写成一个class的时候是需要在html文件中使用的，而使用混合器并不需要在html文件中使用class既可达到复用的效果。</p>
<p>tips:混合器中可以写一切scss代码。</p>
<h3 id="6-继承"><a href="#6-继承" class="headerlink" title="6.继承"></a>6.继承</h3><p>继承是面向对象语言的一大特点，可以大大降低代码量。</p>
<h4 id="6-1定义被继承的样式"><a href="#6-1定义被继承的样式" class="headerlink" title="6.1定义被继承的样式"></a>6.1定义被继承的样式</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">%<span class="attribute">border-style</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#aaa</span>;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用%定义一个被继承的样式，类似静态语言中的抽象类，他本身不起作用，只用于被其他人继承。</p>
<h4 id="6-2继承样式"><a href="#6-2继承样式" class="headerlink" title="6.2继承样式"></a>6.2继承样式</h4><p>通过关键字@extend即可完成继承。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">	<span class="variable">@extend</span> %border-style;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子中看不出混合器与继承之间的区别，那么下一个例子可以看出继承与混合器之间的区别。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">	<span class="variable">@extend</span> %border-style;</span><br><span class="line">	<span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container1</span> &#123;   <span class="comment">//继承另一个选择器</span></span><br><span class="line">	<span class="variable">@extend</span> .container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-其他"><a href="#7-其他" class="headerlink" title="7.其他"></a>7.其他</h3><h4 id="7-1操作符"><a href="#7-1操作符" class="headerlink" title="7.1操作符"></a>7.1操作符</h4><p>SCSS提供了标准的算术运算符，例如+、-、*、&#x2F;、%。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*SCSS*/</span></span><br><span class="line"><span class="attribute">width</span>: <span class="number">600px</span> / <span class="number">960px</span> * <span class="number">100%</span>;</span><br><span class="line"><span class="comment">/*编译后的CSS*/</span></span><br><span class="line"><span class="attribute">width</span>: <span class="number">62.5%</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>Tscript 3.2</title>
    <url>/2022/09/29/ts3-2/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p>Typescript 3.2 发布了几个新特性，主要变化是类型检查更严格，对 ES6、ES7 一些时髦功能拓展了类型支持。</p>
<span id="more"></span>

<h1 id="2-概要"><a href="#2-概要" class="headerlink" title="2 概要"></a>2 概要</h1><p>下面挑一些相对重要配置介绍。</p>
<h2 id="strictBindCallApply"><a href="#strictBindCallApply" class="headerlink" title="strictBindCallApply"></a><code>strictBindCallApply</code></h2><p>对 <code>bind</code> <code>call</code> <code>apply</code> 更严格的类型检测。</p>
<p>比如如下可以检测出 <code>apply</code> 函数参数数量和类型的错误：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = foo.<span class="title function_">apply</span>(<span class="literal">undefined</span>, [<span class="number">10</span>]); <span class="comment">// error: too few argumnts</span></span><br></pre></td></tr></table></figure>

<p>特别对一些 <code>react</code> 老代码，函数需要自己 <code>bind(this)</code>，在没有用箭头函数时，可能经常使用 <code>this.foo = this.foo.bind(this)</code>，这时类型可能会不准，但升级到 TS3.2 后，可以准确捕获到错误了。</p>
<h2 id="Object-spread-类型自动合并"><a href="#Object-spread-类型自动合并" class="headerlink" title="Object spread 类型自动合并"></a>Object spread 类型自动合并</h2><p>现在 <code>Object spread</code> 类型可以自动合并了：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns &#x27;T &amp; U&#x27;</span></span><br><span class="line"><span class="keyword">function</span> merge&lt;T, U&gt;(<span class="attr">x</span>: T, <span class="attr">y</span>: U) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...x, ...y &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object-rest-类型自动剔除"><a href="#Object-rest-类型自动剔除" class="headerlink" title="Object rest 类型自动剔除"></a>Object rest 类型自动剔除</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; x, y, z, ...rest &#125; = obj;</span><br></pre></td></tr></table></figure>

<p>当我们使用了 Object rest 语法时，<code>rest</code> 的类型其实是 <code>obj</code> 类型剔除了 <code>x</code> <code>y</code> <code>z</code> 这三个 key 的类型，现在 ts 已经能自动做到了！</p>
<p>下面是实现方式：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> XYZ &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">any</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">any</span>;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DropXYZ</span>&lt;T&gt; = <span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, keyof <span class="variable constant_">XYZ</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> dropXYZ&lt;T <span class="keyword">extends</span> <span class="variable constant_">XYZ</span>&gt;(<span class="attr">obj</span>: T): <span class="title class_">DropXYZ</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; x, y, z, ...rest &#125; = obj;</span><br><span class="line">  <span class="keyword">return</span> rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>Pick</code> &amp; <code>Exclude</code> 达到剔除 obj 属性的效果，具体可以参考之前的精读：<a href="https://github.com/dt-fe/weekly/blob/master/58.%E7%B2%BE%E8%AF%BB%E3%80%8ATypescript2.0%20-%202.9%E3%80%8B.md#%E5%AF%B9%E7%B1%BB%E5%9E%8B%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%A2%9E%E5%BC%BA">精读《Typescript2.0 - 2.9》</a>。</p>
<h2 id="tsconfig-配置集成支持-node-modules"><a href="#tsconfig-配置集成支持-node-modules" class="headerlink" title="tsconfig 配置集成支持 node_modules"></a>tsconfig 配置集成支持 node_modules</h2><p>这是一个福音，以往在 <code>tsconfig.json</code> 为了继承一个配置，我们需要这么写：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="string">&quot;../node_modules/@my-team/tsconfig-base/tsconfig.json&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>TS3.2 内置了 node_modules 解析，因此就可以更清晰的描述了：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@my-team/tsconfig-base&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="内置-BigInt-类型"><a href="#内置-BigInt-类型" class="headerlink" title="内置 BigInt 类型"></a>内置 BigInt 类型</h2><p>新增了 <code>bigint</code> 类型，再也不会把 <code>bigint</code> 和 <code>number</code> 混淆了。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">bar</span>: <span class="built_in">bigint</span>;</span><br><span class="line"></span><br><span class="line">foo = bar; <span class="comment">// error: Type &#x27;bigint&#x27; is not assignable to type &#x27;number&#x27;.</span></span><br><span class="line">bar = foo; <span class="comment">// error: Type &#x27;number&#x27; is not assignable to type &#x27;bigint&#x27;.</span></span><br></pre></td></tr></table></figure>

<h1 id="3-精读"><a href="#3-精读" class="headerlink" title="3 精读"></a>3 精读</h1><p>这次改动意图非常明显，是为了跟上 JS 的新语法。随着 JS 规范发展，TS 类型必然要得到补充，像 Object spread 与 Object rest 在项目中使用已经非常普遍了，及时完善类型支持，有助于对项目类型的约束。</p>
<p><code>strictBindCallApply</code> 基本可以算是对 React 社区的回馈。在 React 很早期的版本是支持函数自动 <code>bind</code> 的，后来觉得过于 magic 就移除了，由于当时没有箭头函数，大家只好在调用处 <code>.bind(this)</code> 一下。</p>
<p>后来有人发现 <code>.bind(this)</code> 会导致函数引用变化，对 Mutable 性能优化不友好，所以许多代码都在 <code>constructor</code> 位置进行类似 <code>this.fooBind = this.foo.bind(this)</code> 这样的赋值，如今 TS3.2 对这种 <code>bind</code> 过后的函数也具备了严格的类型推测，将会有一大批代码从中受益。</p>
<p>顺带一提，最近 Babel 7.2.0 发布，也带来了一些新特性支持，比如：</p>
<p>提前支持私有属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  #age = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line">  #<span class="title function_">increaseAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#age++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">birthday</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#<span class="title function_">increaseAge</span>();</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Happy Birthday!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提前支持 pipleline Operator：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="number">2</span> |&gt; double |&gt; <span class="number">3</span> + # |&gt; <span class="title function_">toStringBase</span>(<span class="number">2</span>, #); <span class="comment">// &quot;111&quot;</span></span><br></pre></td></tr></table></figure>

<p>整个 JS 生态一篇欣欣向荣的景象。不过 TS 对 ES 规范支持还是比较保守的，比如 Babel 6.x 就支持的 optional chain，现在也没有得到支持，原因是 “等待进入 Stage3”。追踪 ISSUE 可以参考：<a href="https://github.com/Microsoft/TypeScript/issues/16">https://github.com/Microsoft/TypeScript/issues/16</a></p>
<p>如果不清楚 Stage3 的含义，可以阅读前端精读之前的一篇文章：<a href="https://github.com/dt-fe/weekly/blob/master/15.%E7%B2%BE%E8%AF%BB%20TC39%20%E4%B8%8E%20ECMAScript%20%E6%8F%90%E6%A1%88.md">精读 TC39 与 ECMAScript 提案</a>。</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>框架</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>useRef</title>
    <url>/2022/10/11/useRef/</url>
    <content><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p><code>useRef</code> 是常用的 API，但还有一个 <code>createRef</code> 的 API，你知道他们的区别吗？通过 <a href="https://blog.bitsrc.io/react-useref-and-react-createref-the-difference-afedb9877d0f">React.useRef and React.createRef: The Difference</a> 这篇文章，你可以了解到何时该使用它们。</p>
<span id="more"></span>
<h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2 概述"></a>2 概述</h2><p>其实原文就阐述了这样一个事实：<code>useRef</code> 仅能用在 FunctionComponent，<code>createRef</code> 仅能用在 ClassComponent。</p>
<p>第一句话是显然的，因为 Hooks 不能用在 ClassComponent。</p>
<p>第二句话的原因是，<code>createRef</code> 并没有 Hooks 的效果，其值会随着 FunctionComponent 重复执行而不断被初始化：</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 错误用法，永远也拿不到 ref</span></span><br><span class="line">  <span class="keyword">const</span> valueRef = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;valueRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述 <code>valueRef</code> 会随着 App 函数的 Render 而重复初始化，<strong>这也是 Hooks 的独特之处，虽然用在普通函数中，但在 React 引擎中会得到超出普通函数的表现，比如初始化仅执行一次，或者引用不变</strong>。</p>
<p>为什么 <code>createRef</code> 可以在 ClassComponent 正常运行呢？这是因为 ClassComponent 分离了生命周期，使例如 <code>componentDidMount</code> 等初始化时机仅执行一次。</p>
<p>原文完。</p>
<h2 id="3-精读"><a href="#3-精读" class="headerlink" title="3 精读"></a>3 精读</h2><p>那么知道如何正确创建 Ref 后，还知道如何正确更新 Ref 吗？</p>
<p>由于 Ref 是贯穿 FunctionComponent 所有渲染周期的实例，理论上在任何地方都可以做修改，比如：</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> valueRef = <span class="title class_">React</span>.<span class="title function_">useRef</span>();</span><br><span class="line"></span><br><span class="line">  valueRef.<span class="property">current</span> += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但其实上面的修改方式是不规范的，React 官方文档里要求我们避免在 Render 函数中直接修改 Ref，请先看下面的 FunctionComponent 生命周期图：</p>
<img width=600 src="https://img.alicdn.com/tfs/TB12aHDwQL0gK0jSZFtXXXQCXXa-3300-2550.png">

<p>从图中可以发现，在 <code>Render phase</code> 阶段是不允许做 “side effects” 的，也就是写副作用代码，这是因为这个阶段可能会被 React 引擎随时取消或重做。</p>
<p>修改 Ref 属于副作用操作，因此不适合在这个阶段进行。我们可以看到，在 <code>Commit phase</code> 阶段可以做这件事，或者在回调函数中做（脱离了 React 生命周期）。</p>
<p>当然有一种情况是可以的，即 <a href="https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily">懒初始化</a>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Image</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ✅ IntersectionObserver is created lazily once</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getObserver</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ref.<span class="property">current</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      ref.<span class="property">current</span> = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(onIntersect);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ref.<span class="property">current</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// When you need it, call getObserver()</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒初始化的情况下，副作用最多执行一次，而且仅用于初始化赋值，所以这种行为是被允许的。</p>
<p>为什么对副作用限制的如此严格？因为 FunctionComponent 增加了内置调度系统，为了优先响应用户操作，可能会暂定某个 React 组件的渲染，具体可以看第 99 篇精读：<a href="https://github.com/dt-fe/weekly/blob/v2/099.%E7%B2%BE%E8%AF%BB%E3%80%8AScheduling%20in%20React%E3%80%8B.md">精读《Scheduling in React》</a></p>
<p>Ref 不仅可以拿到组件引用、创建一个 Mutable 副作用对象，还可以配合 <code>useEffect</code> 存储一个较老的值，最常用来拿到 <code>previousProps</code>，React 官方利用 Ref 封装了一个简单的 Hooks 拿到上一次的值：</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">usePrevious</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = <span class="title function_">useRef</span>();</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ref.<span class="property">current</span> = value;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> ref.<span class="property">current</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>useEffect</code> 在 Render 完毕后才执行，因此 <code>ref</code> 的值在当前 Render 中永远是上一次 Render 时候的，我们可以利用它拿到上一次 Props：</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> preProps = <span class="title function_">usePrevious</span>(props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要实现这个功能，还是要归功于 <code>ref</code> 可以将值 “在各个不同的 Render 闭包中传递的特性”。最后，不要滥用 Ref，Mutable 引用越多，对 React 来说可维护性一般会越差。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>ts</title>
    <url>/2022/10/11/ts/</url>
    <content><![CDATA[<h1 id="TypeScript快速入门"><a href="#TypeScript快速入门" class="headerlink" title="TypeScript快速入门"></a>TypeScript快速入门</h1><hr>
<br>

<h2 id="1、TypeScript简介"><a href="#1、TypeScript简介" class="headerlink" title="1、TypeScript简介"></a>1、TypeScript简介</h2><ul>
<li><p>ts是js的超集，存在类型的脚本语言;</p>
</li>
<li><p>继承了js的所有编程类型，js代码可在ts环境很好的运行;</p>
</li>
<li><p>新增类型注解和类型推断</p>
</li>
<li><p>拥有丰富的class扩展功能</p>
</li>
<li><p>强大的类型系统，拥有静态类型检查能力</p>
</li>
</ul>
 <br>
 <span id="more"></span>

<h2 id="2、基本类型"><a href="#2、基本类型" class="headerlink" title="2、基本类型"></a>2、基本类型</h2><ul>
<li><p>类型声明</p>
<ul>
<li><p>类型声明是TS非常重要的一个特点</p>
</li>
<li><p>通过类型声明可以指定TS中变量（参数、形参）的类型</p>
</li>
<li><p>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错</p>
</li>
<li><p>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值</p>
</li>
<li><p>语法：</p>
<ul>
<li><p>&#96;&#96;&#96;typescript<br>let 变量: 类型;</p>
<p>let 变量: 类型 &#x3D; 值;</p>
<p>function fn(参数: 类型, 参数: 类型): 类型{<br>…<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 自动类型判断</span><br><span class="line"></span><br><span class="line">  - TS拥有自动的类型判断机制</span><br><span class="line">  - 当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型</span><br><span class="line">  - 所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明</span><br><span class="line"></span><br><span class="line">- 类型：</span><br><span class="line"></span><br><span class="line">  |  类型   |       例子        |              描述              |</span><br><span class="line">  | :-----: | :---------------: | :----------------------------: |</span><br><span class="line">  | number  |    1, -33, 2.5    |            任意数字            |</span><br><span class="line">  | string  | &#x27;hi&#x27;, &quot;hi&quot;, `hi`  |           任意字符串           |</span><br><span class="line">  | boolean |    true、false    |       布尔值true或false        |</span><br><span class="line">  | 字面量  |      其本身       |  限制变量的值就是该字面量的值  |</span><br><span class="line">  |   any   |         *         |            任意类型            |</span><br><span class="line">  | unknown |         *         |         类型安全的any          |</span><br><span class="line">  |  void   | 空值（undefined） |     没有值（或undefined）      |</span><br><span class="line">  |  never  |      没有值       |          不能是任何值          |</span><br><span class="line">  | object  |  &#123;name:&#x27;孙悟空&#x27;&#125;  |          任意的JS对象          |</span><br><span class="line">  |  array  |      [1,2,3]      |           任意JS数组           |</span><br><span class="line">  |  tuple  |       [4,5]       | 元组，TS新增类型，固定长度数组 |</span><br><span class="line">  |  enum   |    enum&#123;A, B&#125;     |       枚举，TS中新增类型       |</span><br><span class="line"></span><br><span class="line">- number(数字型)</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let decimal: number = 6;</span><br><span class="line">    let hex: number = 0xf00d;</span><br><span class="line">    let binary: number = 0b1010;</span><br><span class="line">    let octal: number = 0o744;</span><br><span class="line">    let big: bigint = 100n;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>boolean(布尔型)</p>
<ul>
<li>&#96;&#96;&#96;typescript<br>let isDone: boolean &#x3D; false;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- string(字符串型)</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let color: string = &quot;blue&quot;;</span><br><span class="line">    color = &#x27;red&#x27;;</span><br><span class="line">    </span><br><span class="line">    let fullName: string = `Bob Bobbington`;</span><br><span class="line">    let age: number = 37;</span><br><span class="line">    let sentence: string = `Hello, my name is $&#123;fullName&#125;.</span><br><span class="line">    </span><br><span class="line">    I&#x27;ll be $&#123;age + 1&#125; years old next month.`;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>字面量</p>
<ul>
<li><p>也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围</p>
</li>
<li><p>&#96;&#96;&#96;typescript<br>let color: ‘red’ | ‘blue’ | ‘black’;<br>let num: 1 | 2 | 3 | 4 | 5;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- any(任意型)</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let d: any = 4;</span><br><span class="line">    d = &#x27;hello&#x27;;</span><br><span class="line">    d = true;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>unknown(类型安全的any)；</p>
<ul>
<li><p><strong>注意</strong>:unknown和any都是TS中的顶级类型，但主要区别在于：<strong>使用any相当于彻底放弃了类型检查</strong>，而unknown类型相较于any更加严格，在执行大多数操作之前，会进行某种形式的检查(不允许访问属性，不允许赋值给其他有明确类型的变量)。</p>
</li>
<li><p>&#96;&#96;&#96;typescript<br>let notSure: unknown &#x3D; 4;<br>notSure &#x3D; ‘hello’;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- void</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let unusable: void = undefined;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>never</p>
<ul>
<li>&#96;&#96;&#96;typescript<br>function error(message: string): never {<br>  throw new Error(message);<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- object(不怎么用)</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let obj: object = &#123;&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>array</p>
<ul>
<li>&#96;&#96;&#96;typescript<br>let list: number[] &#x3D; [1, 2, 3];<br>let list: Array<number> &#x3D; [1, 2, 3];<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- tuple</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let x: [string, number];</span><br><span class="line">    x = [&quot;hello&quot;, 10]; </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>enum</p>
<ul>
<li><p>&#96;&#96;&#96;typescript<br>enum Color {<br>  Red,<br>  Green,<br>  Blue,<br>}<br>let c: Color &#x3D; Color.Green;</p>
<p>enum Color {<br>  Red &#x3D; 1,<br>  Green,<br>  Blue,<br>}<br>let c: Color &#x3D; Color.Green;</p>
<p>enum Color {<br>  Red &#x3D; 1,<br>  Green &#x3D; 2,<br>  Blue &#x3D; 4,<br>}<br>let c: Color &#x3D; Color.Green;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 类型断言</span><br><span class="line"></span><br><span class="line">  - 类型断言就相当于在编译阶段进行类型转换；</span><br><span class="line"></span><br><span class="line">  - 有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</span><br><span class="line"></span><br><span class="line">    - 第一种</span><br><span class="line">  </span><br><span class="line">      - ```typescript</span><br><span class="line">        let someValue: unknown = &quot;this is a string&quot;;</span><br><span class="line">        let strLength: number = (someValue as string).length;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第二种</p>
<ul>
<li>&#96;&#96;&#96;typescript<br>let someValue: unknown &#x3D; “this is a string”;<br>let strLength: number &#x3D; (<string>someValue).length;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">## 3、编译选项</span><br><span class="line"></span><br><span class="line">- 自动编译文件</span><br><span class="line"></span><br><span class="line">  - 编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```powershell</span><br><span class="line">      tsc xxx.ts -w</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>自动编译整个项目</p>
<ul>
<li><p>如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。</p>
</li>
<li><p>但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json</p>
</li>
<li><p>tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译</p>
</li>
<li><p>配置选项：</p>
<ul>
<li><p>include</p>
<ul>
<li><p>定义希望被编译文件所在的目录</p>
</li>
<li><p>默认值：[“**&#x2F;*“]</p>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="json">&quot;include&quot;:[&quot;src/**/*&quot;, &quot;tests/**/*&quot;]
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 上述示例中，所有src目录和tests目录下的文件都会被编译</span><br><span class="line"></span><br><span class="line">- exclude</span><br><span class="line"></span><br><span class="line">  - 定义需要排除在外的目录</span><br><span class="line"></span><br><span class="line">  - 默认值：[&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;]</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;exclude&quot;: [&quot;./src/hello/**/*&quot;]</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>上述示例中，src下hello目录下的文件都不会被编译</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>extends</p>
<ul>
<li><p>定义被继承的配置文件</p>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="json">&quot;extends&quot;: &quot;./configs/base&quot;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息</span><br><span class="line"></span><br><span class="line">- files</span><br><span class="line"></span><br><span class="line">  - 指定被编译文件的列表，只有需要编译的文件少时才会用到</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;files&quot;: [</span><br><span class="line">          &quot;core.ts&quot;,</span><br><span class="line">          &quot;sys.ts&quot;,</span><br><span class="line">          &quot;types.ts&quot;,</span><br><span class="line">          &quot;scanner.ts&quot;,</span><br><span class="line">          &quot;parser.ts&quot;,</span><br><span class="line">          &quot;utilities.ts&quot;,</span><br><span class="line">          &quot;binder.ts&quot;,</span><br><span class="line">          &quot;checker.ts&quot;,</span><br><span class="line">          &quot;tsc.ts&quot;</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>列表中的文件都会被TS编译器所编译</p>
</li>
</ul>
</li>
<li><p>compilerOptions</p>
<ul>
<li><p>编译选项是配置文件中非常重要也比较复杂的配置选项</p>
</li>
<li><p>在compilerOptions中包含多个子选项，用来完成对编译的配置</p>
<ul>
<li><p>项目选项</p>
<ul>
<li><p>target</p>
<ul>
<li><p>设置ts代码编译的目标版本</p>
</li>
<li><p>可选值：</p>
<ul>
<li>ES3（默认）、ES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li>&#96;&#96;&#96;json<br>“compilerOptions”: {<br>“target”: “ES6”<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码</span><br><span class="line"></span><br><span class="line">- lib</span><br><span class="line"></span><br><span class="line">  - 指定代码运行时所包含的库（宿主环境）</span><br><span class="line"></span><br><span class="line">  - 可选值：</span><br><span class="line"></span><br><span class="line">    - ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;compilerOptions&quot;: &#123;</span><br><span class="line">          &quot;target&quot;: &quot;ES6&quot;,</span><br><span class="line">          &quot;lib&quot;: [&quot;ES6&quot;, &quot;DOM&quot;],</span><br><span class="line">          &quot;outDir&quot;: &quot;dist&quot;,</span><br><span class="line">          &quot;outFile&quot;: &quot;dist/aa.js&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>module</p>
<ul>
<li><p>设置编译后代码使用的模块化系统</p>
</li>
<li><p>可选值：</p>
<ul>
<li>CommonJS、UMD、AMD、System、ES2020、ESNext、None</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="typescript">&quot;compilerOptions&quot;: &#123;
    &quot;module&quot;: &quot;CommonJS&quot;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- outDir</span><br><span class="line"></span><br><span class="line">  - 编译后文件的所在目录</span><br><span class="line"></span><br><span class="line">  - 默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;compilerOptions&quot;: &#123;</span><br><span class="line">          &quot;outDir&quot;: &quot;dist&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>设置后编译后的js文件将会生成到dist目录</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>outFile</p>
<ul>
<li><p>将所有的文件编译为一个js文件</p>
</li>
<li><p>默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中</p>
</li>
<li><p>示例：</p>
<ul>
<li>&#96;&#96;&#96;json<br>“compilerOptions”: {<br>“outFile”: “dist&#x2F;app.js”<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- rootDir</span><br><span class="line"></span><br><span class="line">  - 指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;compilerOptions&quot;: &#123;</span><br><span class="line">          &quot;rootDir&quot;: &quot;./src&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>allowJs</p>
<ul>
<li>是否对js文件编译</li>
</ul>
</li>
<li><p>checkJs</p>
<ul>
<li><p>是否对js文件进行检查</p>
</li>
<li><p>示例：</p>
<ul>
<li>&#96;&#96;&#96;json<br>“compilerOptions”: {<br>“allowJs”: true,<br>“checkJs”: true<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">            - removeComments</span><br><span class="line"></span><br><span class="line">              - 是否删除注释</span><br><span class="line">              - 默认值：false</span><br><span class="line"></span><br><span class="line">            - noEmit</span><br><span class="line"></span><br><span class="line">              - 不对代码进行编译</span><br><span class="line">              - 默认值：false</span><br><span class="line"></span><br><span class="line">            - sourceMap</span><br><span class="line"></span><br><span class="line">              - 是否生成sourceMap</span><br><span class="line">              - 默认值：false</span><br><span class="line"></span><br><span class="line">              </span><br><span class="line"></span><br><span class="line">          - 严格检查</span><br><span class="line"></span><br><span class="line">            - strict</span><br><span class="line">              - 启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查</span><br><span class="line">            - alwaysStrict</span><br><span class="line">              - 总是以严格模式对代码进行编译</span><br><span class="line">            - noImplicitAny</span><br><span class="line">              - 禁止隐式的any类型</span><br><span class="line">            - noImplicitThis</span><br><span class="line">              - 禁止类型不明确的this</span><br><span class="line">            - strictBindCallApply</span><br><span class="line">              - 严格检查bind、call和apply的参数列表</span><br><span class="line">            - strictFunctionTypes</span><br><span class="line">              - 严格检查函数的类型</span><br><span class="line">            - strictNullChecks</span><br><span class="line">              - 严格的空值检查</span><br><span class="line">            - strictPropertyInitialization</span><br><span class="line">              - 严格检查属性是否初始化</span><br><span class="line"></span><br><span class="line">          - 额外检查</span><br><span class="line"></span><br><span class="line">            - noFallthroughCasesInSwitch</span><br><span class="line">              - 检查switch语句包含正确的break</span><br><span class="line">            - noImplicitReturns</span><br><span class="line">              - 检查函数没有隐式的返回值</span><br><span class="line">            - noUnusedLocals</span><br><span class="line">              - 检查未使用的局部变量</span><br><span class="line">            - noUnusedParameters</span><br><span class="line">              - 检查未使用的参数</span><br><span class="line"></span><br><span class="line">          - 高级</span><br><span class="line"></span><br><span class="line">            - allowUnreachableCode</span><br><span class="line">              - 检查不可达代码</span><br><span class="line">              - 可选值：</span><br><span class="line">                - true，忽略不可达代码</span><br><span class="line">                - false，不可达代码将引起错误</span><br><span class="line">            - noEmitOnError</span><br><span class="line">              - 有错误的情况下不进行编译</span><br><span class="line">              - 默认值：false</span><br><span class="line"></span><br><span class="line">## 4、webpack</span><br><span class="line"></span><br><span class="line">- 通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。</span><br><span class="line"></span><br><span class="line">- 步骤：</span><br><span class="line"></span><br><span class="line">  1. 初始化项目</span><br><span class="line"></span><br><span class="line">     - 进入项目根目录，执行命令 ``` npm init -y```</span><br><span class="line">       - 主要作用：创建package.json文件</span><br><span class="line"></span><br><span class="line">  2. 下载构建工具</span><br><span class="line"></span><br><span class="line">     - ```npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin```</span><br><span class="line">       - 共安装了7个包</span><br><span class="line">         - webpack</span><br><span class="line">           - 构建工具webpack</span><br><span class="line">         - webpack-cli</span><br><span class="line">           - webpack的命令行工具</span><br><span class="line">         - webpack-dev-server</span><br><span class="line">           - webpack的开发服务器</span><br><span class="line">         - typescript</span><br><span class="line">           - ts编译器</span><br><span class="line">         - ts-loader</span><br><span class="line">           - ts加载器，用于在webpack中编译ts文件</span><br><span class="line">         - html-webpack-plugin</span><br><span class="line">           - webpack中html插件，用来自动创建html文件</span><br><span class="line">         - clean-webpack-plugin</span><br><span class="line">           - webpack中的清除插件，每次构建都会先清除目录</span><br><span class="line"></span><br><span class="line">  3. 根目录下创建webpack的配置文件webpack.config.js</span><br><span class="line"></span><br><span class="line">     - ```javascript</span><br><span class="line">       const path = require(&quot;path&quot;);</span><br><span class="line">       const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);</span><br><span class="line">       const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);</span><br><span class="line">       </span><br><span class="line">       module.exports = &#123;</span><br><span class="line">           optimization:&#123;</span><br><span class="line">               minimize: false // 关闭代码压缩，可选</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           entry: &quot;./src/index.ts&quot;,</span><br><span class="line">           </span><br><span class="line">           devtool: &quot;inline-source-map&quot;,</span><br><span class="line">           </span><br><span class="line">           devServer: &#123;</span><br><span class="line">               contentBase: &#x27;./dist&#x27;</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           output: &#123;</span><br><span class="line">               path: path.resolve(__dirname, &quot;dist&quot;),</span><br><span class="line">               filename: &quot;bundle.js&quot;,</span><br><span class="line">               environment: &#123;</span><br><span class="line">                   arrowFunction: false // 关闭webpack的箭头函数，可选</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           resolve: &#123;</span><br><span class="line">               extensions: [&quot;.ts&quot;, &quot;.js&quot;]</span><br><span class="line">           &#125;,</span><br><span class="line">           </span><br><span class="line">           module: &#123;</span><br><span class="line">               rules: [</span><br><span class="line">                   &#123;</span><br><span class="line">                       test: /\.ts$/,</span><br><span class="line">                       use: &#123;</span><br><span class="line">                          loader: &quot;ts-loader&quot;     </span><br><span class="line">                       &#125;,</span><br><span class="line">                       exclude: /node_modules/</span><br><span class="line">                   &#125;</span><br><span class="line">               ]</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           plugins: [</span><br><span class="line">               new CleanWebpackPlugin(),</span><br><span class="line">               new HtmlWebpackPlugin(&#123;</span><br><span class="line">                   title:&#x27;TS测试&#x27;</span><br><span class="line">               &#125;),</span><br><span class="line">           ]</span><br><span class="line">       </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li><p>根目录下创建tsconfig.json，配置可以根据自己需要</p>
<ul>
<li>&#96;&#96;&#96;json<br>{<br>“compilerOptions”: {<br>    “target”: “ES2015”,<br>    “module”: “ES2015”,<br>    “strict”: true<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. 修改package.json添加如下配置</span><br><span class="line"></span><br><span class="line">   - ```json</span><br><span class="line">     &#123;</span><br><span class="line">       ...略...</span><br><span class="line">       &quot;scripts&quot;: &#123;</span><br><span class="line">         &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">         &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">         &quot;start&quot;: &quot;webpack serve --open chrome.exe&quot;</span><br><span class="line">       &#125;,</span><br><span class="line">       ...略...</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在src下创建ts文件，并在并命令行执行<code>npm run build</code>对代码进行编译，或者执行<code>npm start</code>来启动开发服务器</p>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>React自定义路由&amp;&amp;路由守卫</title>
    <url>/2022/10/08/routerShouWei/</url>
    <content><![CDATA[<h1 id="React自定义路由以及路由守卫"><a href="#React自定义路由以及路由守卫" class="headerlink" title="React自定义路由以及路由守卫"></a>React自定义路由以及路由守卫</h1><p>react路由v6版本提供了和Vue相像的路由表，但是相比Vue还是少了一点东西。官方所谓的“提供更多自由度”好是好。但我觉得太高的自由度对于开发来说效率上会大大折扣。重复性的造轮子倒不如使用提供的。。。</p>
<span id="more"></span>

<h2 id="Vue中的路由"><a href="#Vue中的路由" class="headerlink" title="Vue中的路由"></a>Vue中的路由</h2><p>Vue提供的现成的路由Api方便了对路由的监听，在这两个钩子中可以对路由进行常用的 <em>鉴权</em>  等操作…</p>
<p>特别方便😍</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...路由表</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/components/common/404/Error.vue&#x27;</span>),</span><br><span class="line">    <span class="attr">meta</span>: &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;404-s.kr&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  routes,</span><br><span class="line">  <span class="title function_">scrollBehavior</span>(<span class="params">to, <span class="keyword">from</span>, savedPosition</span>) &#123; <span class="comment">// 解决vue页面跳转只有页面不是在顶部的问题</span></span><br><span class="line">    <span class="comment">// savedPosition 会在你使用浏览器前进或后退按钮时候生效</span></span><br><span class="line">    <span class="keyword">if</span> (savedPosition) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">selector</span>: savedPosition</span><br><span class="line">      &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂载路由导航守卫</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 路由跳转开始</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 路由跳转完毕</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="React路由"><a href="#React路由" class="headerlink" title="React路由"></a>React路由</h1><p>在React中，Router v5版本没有路由表这种东西，需要自己写<code>&lt;Route&gt;&lt;/Route&gt;</code>等…</p>
<p>但在v6版本中可以配置路由表，通过<code>useRoutes(routes)</code>可以生成v5当中的路由配置</p>
<blockquote>
<p>V6版本当中要自己封装一套类<code>useRoutes(routes)</code>生成路由配置</p>
</blockquote>
<p>路由的配置要根据情况！直接上代码:</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React 组件懒加载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装快速导入工具函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">lazyLoad</span> = (<span class="params">moduleName: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="title class_">NProgress</span>.<span class="title function_">start</span>() <span class="comment">// 显示进度条</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Module</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">`pages/<span class="subst">$&#123;moduleName&#125;</span>`</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Module</span>&gt;</span><span class="tag">&lt;/<span class="name">Module</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由鉴权组件</span></span><br><span class="line"><span class="comment">// 高阶组件--将传入的路由组件进行鉴权判定</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Appraisal</span> = (<span class="params">&#123; children &#125;: <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">getCookie</span>(<span class="string">&quot;userinfo&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 判断本地 是否 存有 Cookie</span></span><br><span class="line">        <span class="comment">// 如果没有 就 重定向到登陆页面</span></span><br><span class="line">        message.<span class="title function_">warning</span>(<span class="string">&#x27;请先登录~&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">replace</span> /&gt;</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> children</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Router</span> &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="built_in">string</span>, <span class="comment">// 路由路径</span></span><br><span class="line">    children?: <span class="title class_">Array</span>&lt;<span class="title class_">Router</span>&gt;,  <span class="comment">// 子路由</span></span><br><span class="line">    <span class="attr">element</span>: <span class="built_in">any</span>, <span class="comment">// 路由页面</span></span><br><span class="line">    auth?: <span class="built_in">boolean</span> <span class="comment">// 需要路由鉴权</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Router</span>&gt; = [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主页</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">        <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Home</span>&gt;</span><span class="tag">&lt;/<span class="name">Home</span>&gt;</span></span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 搜索</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/search&#x27;</span>,</span><br><span class="line">        <span class="attr">element</span>: <span class="title function_">lazyLoad</span>(<span class="string">&#x27;Search&#x27;</span>),</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;product/:name&#x27;</span>,</span><br><span class="line">                <span class="attr">element</span>: <span class="title function_">lazyLoad</span>(<span class="string">&#x27;Product&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;activity&#x27;</span>,</span><br><span class="line">                <span class="attr">element</span>: <span class="title function_">lazyLoad</span>(<span class="string">&#x27;Activity&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;show&#x27;</span>,</span><br><span class="line">                <span class="attr">element</span>: <span class="title function_">lazyLoad</span>(<span class="string">&#x27;Show&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;/search&#x27;</span>,</span><br><span class="line">                <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/search/product&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Navigate</span>&gt;</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 底部路由跳转</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="comment">// 关于我们</span></span><br><span class="line">        <span class="attr">element</span>: <span class="title function_">lazyLoad</span>(<span class="string">&#x27;About&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 MyRouter 函数动态生成路由配置</span></span><br><span class="line"><span class="comment">// 这种 路由生成仅限两层路由</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyRouter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">Loading</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;</span></span><br><span class="line"><span class="language-xml">                    routes.map((item, index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">                        // 判断是否需要鉴权</span></span><br><span class="line"><span class="language-xml">                        if (item.auth) &#123;</span></span><br><span class="line"><span class="language-xml">                            return <span class="tag">&lt;<span class="name">Route</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">path</span>=<span class="string">&#123;item.path&#125;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Appraisal</span>&gt;</span>&#123;item.element&#125;<span class="tag">&lt;/<span class="name">Appraisal</span>&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        &#125;</span></span><br><span class="line"><span class="language-xml">                        // 判断是否有子路由</span></span><br><span class="line"><span class="language-xml">                        return (item.children ?</span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">path</span>=<span class="string">&#123;item.path&#125;</span> <span class="attr">element</span>=<span class="string">&#123;item.element&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                                &#123;</span></span><br><span class="line"><span class="language-xml">                                    item.children.map((e, i) =&gt;</span></span><br><span class="line"><span class="language-xml">                                        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">key</span>=<span class="string">&#123;i&#125;</span> <span class="attr">path</span>=<span class="string">&#123;e.path&#125;</span> <span class="attr">element</span>=<span class="string">&#123;e.element&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                                    )</span></span><br><span class="line"><span class="language-xml">                                &#125;</span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;/<span class="name">Route</span>&gt;</span> :</span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">path</span>=<span class="string">&#123;item.path&#125;</span> <span class="attr">element</span>=<span class="string">&#123;item.element&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        )</span></span><br><span class="line"><span class="language-xml">                    &#125;)</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyRouter</span>;</span><br></pre></td></tr></table></figure>

<h3 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h3><p>有些情况下，我们所展示的页面有些是需要公共底部导航的，但是有些页面是不需要的。我就需要根据实际情况配置路由；(此配置没有路由守卫)</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lazy,<span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    <span class="title class_">BrowserRouter</span>,</span><br><span class="line">    <span class="title class_">Routes</span>,<span class="title class_">Route</span>,</span><br><span class="line">    <span class="title class_">Navigate</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> routeType&#123;</span><br><span class="line">  path?:<span class="built_in">string</span></span><br><span class="line">  element?:<span class="title class_">React</span>.<span class="property">ReactNode</span></span><br><span class="line">  children?:<span class="title class_">Array</span>&lt;routeType&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数组每一项的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IRoute</span> &#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">component</span>:<span class="title class_">React</span>.<span class="property">FC</span>;</span><br><span class="line">  children?:<span class="title class_">Array</span>&lt;<span class="title class_">IRoute</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">router_arr</span>:<span class="title class_">IRoute</span>[] = [</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&quot;/&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>:<span class="title class_">App</span>,</span><br><span class="line">      <span class="attr">children</span>:[</span><br><span class="line">          &#123;<span class="attr">path</span>:<span class="string">&quot;/home&quot;</span>,<span class="attr">component</span>:<span class="title function_">lazy</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&quot;pages/Home&quot;</span>))&#125;,</span><br><span class="line">          &#123;<span class="attr">path</span>:<span class="string">&quot;/sort&quot;</span>,<span class="attr">component</span>:<span class="title function_">lazy</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&quot;pages/Sort&quot;</span>))&#125;,</span><br><span class="line">          &#123;<span class="attr">path</span>:<span class="string">&quot;/shopcar&quot;</span>,<span class="attr">component</span>:<span class="title function_">lazy</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&quot;pages/ShopCar&quot;</span>))&#125;,</span><br><span class="line">          &#123;<span class="attr">path</span>:<span class="string">&quot;/usercenter&quot;</span>,<span class="attr">component</span>:<span class="title function_">lazy</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&quot;pages/UserCenter&quot;</span>))&#125;,</span><br><span class="line">          &#123;<span class="attr">path</span>:<span class="string">&quot;/&quot;</span>,<span class="attr">component</span>:<span class="title function_">lazy</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&quot;pages/Home&quot;</span>))&#125;,</span><br><span class="line">      ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&quot;/login&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>:<span class="title function_">lazy</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&quot;pages/Login&quot;</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&quot;/search&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>:<span class="title function_">lazy</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&quot;pages/Search&quot;</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&quot;/register&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>:<span class="title function_">lazy</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&quot;pages/Register&quot;</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&quot;*&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>:<span class="title function_">lazy</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&quot;pages/404&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyRouter</span> = (<span class="params"></span>)=&gt;(</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Routes</span>&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">        router_arr.map((item,index)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">            if (item.path===&#x27;*&#x27;) &#123;</span></span><br><span class="line"><span class="language-xml">                return <span class="tag">&lt;<span class="name">Route</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">path</span>=<span class="string">&#123;item.path&#125;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">item.component</span>/&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">            return (item.children ?</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">path</span>=<span class="string">&#123;item.path&#125;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">item.component</span>/&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                &#123;</span></span><br><span class="line"><span class="language-xml">                    item.children.map((e,i)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">                        if (e.path === &#x27;/&#x27;) &#123;</span></span><br><span class="line"><span class="language-xml">                            return <span class="tag">&lt;<span class="name">Route</span> <span class="attr">key</span>=<span class="string">&#123;i&#125;</span> <span class="attr">path</span>=<span class="string">&#123;e.path&#125;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>/&gt;</span>&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">                        &#125;</span></span><br><span class="line"><span class="language-xml">                        return <span class="tag">&lt;<span class="name">Route</span> <span class="attr">key</span>=<span class="string">&#123;i&#125;</span> <span class="attr">path</span>=<span class="string">&#123;e.path&#125;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">e.component</span>/&gt;</span>&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">                    &#125;)</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Route</span>&gt;</span>:</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">path</span>=<span class="string">&#123;item.path&#125;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">item.component</span>/&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        )&#125;)</span></span><br><span class="line"><span class="language-xml">        &#125;<span class="tag">&lt;/<span class="name">Routes</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span>   </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyRouter</span></span><br></pre></td></tr></table></figure>

<p>这种配置下的路由，就需要将<code>&lt;MyRouter/&gt;</code>配置到入口函数：</p>
<p>这种路由配置，可解决部分页面需要底部导航，而有些页面却不需要。就比如说登录页，注册页等等。。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MyRouter</span> <span class="keyword">from</span> <span class="string">&#x27;router/router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>) <span class="keyword">as</span> <span class="title class_">HTMLElement</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">root.<span class="title function_">render</span>( </span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">MyRouter</span> /&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>而App组件中就需要这样写：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Outlet</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">FooterLink</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>框架</tag>
        <tag>路由</tag>
      </tags>
  </entry>
</search>
