<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hygen</title>
    <url>/2022/08/31/Hygen/</url>
    <content><![CDATA[<h1 id="Hygen模板生成器"><a href="#Hygen模板生成器" class="headerlink" title="Hygen模板生成器"></a>Hygen模板生成器</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装：<code>npm i -g hygen </code></p>
<p>初始化hygen：<code>hygen init self</code></p>
<h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>生成模板：<code>hygen generator new component</code></p>
<p><img src="https://found-img-blog.oss-cn-hangzhou.aliyuncs.com/img/image-20220831210053873.png" alt="image-20220831210053873"></p>
<span id="more"></span>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>这里面的<code>.ejs.t</code>后缀文件就是一个个模板</p>
<ul>
<li><code>---</code>分割部分标识模板生成路径</li>
<li><code>&lt;%= name %&gt;</code>表示组件名字，也对应了下文指令</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="symbol">to:</span> src/components/&lt;%= name %&gt;/index.js</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> from <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> from <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Styled</span>&lt;%= name %&gt; from <span class="string">&#x27;./style&#x27;</span></span><br><span class="line"></span><br><span class="line">function &lt;%= name %&gt;(&#123;</span><br><span class="line">    children,</span><br><span class="line">  ...rest</span><br><span class="line">&#125;)&#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;<span class="title class_">Styled</span>&lt;%= name %&gt; &#123;...rest&#125;&gt;</span><br><span class="line">        children</span><br><span class="line">    &lt;/<span class="title class_">Styled</span>&lt;%= name %&gt;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%= name %&gt;.propTypes = &#123;</span><br><span class="line">    <span class="symbol">children:</span><span class="title class_">PropTypes</span>.any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &lt;%= name %&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>对于需要大写的模板可以使用内置的方法<ul>
<li><code>h.changeCase.lcFirst(name)</code></li>
</ul>
</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="symbol">to:</span> src/components/&lt;%= name %&gt;/&lt;%= h.changeCase.lcFirst(name) %&gt;.stories.js</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> from <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &lt;%= name %&gt; from <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    <span class="symbol">title:</span><span class="string">&quot;&lt;%= name %&gt;&quot;</span>,</span><br><span class="line">    <span class="symbol">component:</span>&lt;%= name %&gt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export const <span class="title class_">Default</span> = ()=&gt; &lt;&lt;%= name %&gt;&gt;默认&lt;&lt;%= name %&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>使用对应模板生成内容：</p>
<p><code>hygen component new Icon</code>    <em>这个Icon是自定义名字</em></p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>这个<strong>component</strong>叫做生成器，而<strong>new</strong>叫做action</p>
<p>一个hygen可以有多个生成器，一个生成器可以有多个action</p>
<blockquote>
<p>有趣的是上文中的<code>hygen generator new component</code>叫做生成器的生成器。</p>
<p>这个Icon对应上文中的<code>&lt;%= name %&gt;</code></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hygen</tag>
        <tag>模板</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Storybook</title>
    <url>/2022/09/07/Storybook/</url>
    <content><![CDATA[<h1 id="Storybook"><a href="#Storybook" class="headerlink" title="Storybook"></a>Storybook</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Storybook是帮助前端组件开发的开源工具，可以支持React，Vue，Angular等框架。</p>
<blockquote>
<p>它的网站首页这样说道：storybook 为UI组件提供一个独立的沙箱环境，在这里无论是edge case还是难于遇到的状态都可以造出来。可以把use case 像故事一样展现出来。</p>
</blockquote>
<p>平常的组件开发，程序猿需要把组件单独放置在一个页面不断的调试，非常不人性化。而storybook就单独为开发人员提供了一个页面，将组件放置在他们提供的页面中清晰可见。</p>
<p>简单的说，如果我们是开发react组件，就不需要启动react的打包编译启动页面浏览组件，只需要启动storybook为我们内置的页面即可浏览组建</p>
<p><img src="https://found-img-blog.oss-cn-hangzhou.aliyuncs.com/img/image-20220831232821238.png" alt="image-20220831232821238"></p>
<span id="more"></span>

<p>这样，单个组件的样式更好的展示出来。而且自动生成组件所需的API表</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这里我们以<code>React app</code>为例，如何在React脚手架中配置<code>storybook</code></p>
<p><span style="color:red">注意新旧版本示例文件有所不同!!!</span></p>
<ul>
<li>根目录执行：<code>npx -p @storybook/cli sb init</code><ul>
<li>自动配置项目并生成实例文件，如下：</li>
</ul>
</li>
</ul>
<p><img src="https://found-img-blog.oss-cn-hangzhou.aliyuncs.com/img/image-20220831233500985.png" alt="image-20220831233500985"></p>
<ul>
<li>启动：<code>yarn run storybook</code><ul>
<li>左边就是组件的目录</li>
</ul>
</li>
</ul>
<p><img src="https://found-img-blog.oss-cn-hangzhou.aliyuncs.com/img/image-20220831233608493.png" alt="image-20220831233608493"></p>
<h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>打开<code>Header.stories.jsx</code>文件</p>
<blockquote>
<p>我们可以在metadata 里面定义一些参数（parameters）这样可以提供一些配置上的灵活性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Header</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./Header&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Example/Header&#x27;</span>, <span class="comment">//---左侧目录配置</span></span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">Header</span>, <span class="comment">//---指定具体的组件</span></span><br><span class="line">  <span class="attr">parameters</span>: &#123; <span class="comment">//---自定义参数</span></span><br><span class="line">    <span class="attr">layout</span>: <span class="string">&#x27;fullscreen&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Template</span> = (<span class="params">args</span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">Header</span> &#123;<span class="attr">...args</span>&#125; /&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">LoggedIn</span> = <span class="title class_">Template</span>.<span class="title function_">bind</span>(&#123;&#125;);</span><br><span class="line"><span class="title class_">LoggedIn</span>.<span class="property">args</span> = &#123;</span><br><span class="line">  <span class="attr">user</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jane Doe&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">LoggedOut</span> = <span class="title class_">Template</span>.<span class="title function_">bind</span>(&#123;&#125;);</span><br><span class="line"><span class="title class_">LoggedOut</span>.<span class="property">args</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><code>LoggedIn.args</code>是配置组件属性的<em>默认值</em></p>
<p><img src="https://found-img-blog.oss-cn-hangzhou.aliyuncs.com/img/image-20220831235417873.png" alt="image-20220831235417873"></p>
<h2 id="配合Styled-components"><a href="#配合Styled-components" class="headerlink" title="配合Styled-components"></a>配合Styled-components</h2><p>配置<strong>Styled-components</strong>主题</p>
<p>因为storybook是独立于react creat app的，所以需要为storybook再配置一下主题</p>
<ul>
<li><p>在<code>.storybook</code>文件下创建<code>preview.js</code>文件</p>
</li>
<li><pre><code class="js">import React from &quot;react&quot;;
import &#123; addDecorator,addParameters &#125; from &quot;@storybook/react&quot;;
import &#123; ThemeProvider &#125; from &quot;styled-components&quot;;
import theme from &#39;../src/theme&#39;; //---theme为全局变量配置，类似less的全局变量配置文件

import &#39;story.css&#39;;

addDecorator((storyFn)=&gt;(
  &lt;ThemeProvider theme=&#123;theme&#125;&gt;&#123;storyFn()&#125;&lt;/ThemeProvider&gt;
))
</code></pre>
</li>
</ul>
<h2 id="更多…"><a href="#更多…" class="headerlink" title="更多…"></a>更多…</h2>]]></content>
      <categories>
        <category>框架</category>
        <category>React</category>
        <category>组件</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Storybook</tag>
        <tag>组件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>js闭包_深入浅出</title>
    <url>/2022/09/07/js-closure/</url>
    <content><![CDATA[<h2 id="简单的对闭包做一个理解："><a href="#简单的对闭包做一个理解：" class="headerlink" title="简单的对闭包做一个理解："></a>简单的对<strong>闭包</strong>做一个理解：</h2><ul>
<li>闭包产生是：函数内嵌套函数；</li>
<li>闭包函数在外面被调用，访问；</li>
<li>闭包能使外部函数访问内部函数的变量；</li>
<li>闭包可以保持对定义时的作用域的引用，使之不被销毁，就长生不老。</li>
</ul>
<h3 id="在看闭包之前我们还需要理解作用域。"><a href="#在看闭包之前我们还需要理解作用域。" class="headerlink" title="在看闭包之前我们还需要理解作用域。"></a>在看闭包之前我们还需要理解<strong>作用域</strong>。</h3><blockquote>
<p>作用域主要分为两种：全局变量和局部变量。</p>
</blockquote>
<span id="more"></span>

<h5 id="全局变量-amp-局部变量"><a href="#全局变量-amp-局部变量" class="headerlink" title="全局变量&amp;局部变量"></a><strong>全局变量&amp;局部变量</strong></h5><p><strong>局部变量</strong>:定义在函数内部，只能在函数中使用的变量，作用范围是从函数开始到结尾，即在<strong>｛｝</strong>里。<br>这里定义的<code>a</code>就是局部变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myTest1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//a is not defined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">myTest1</span>());<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p><strong>全局变量</strong>：常常定义在函数外部，拥有全局作用域，即在 JavaScript 代码的任何地方都可以访问</p>
<p>这里定义的<code>b</code>就是局部变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myTest2</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> b;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myTest2</span>());<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>从这里我们就可以知道，函数内部可以调用<strong>全局变量</strong>，但是函数外部无法读取函数内的<strong>局部变量</strong></p>
<p>函数内部声明变量的时候，必须使用var命令去声明一个变量。如果不用的话，就会声明了一个<strong>全局变量</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myTest3</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">4</span>;</span><br><span class="line">    d=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> c,d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">myTest3</span>());<span class="comment">//4,3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d);<span class="comment">//3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);<span class="comment">//c is not defined</span></span><br></pre></td></tr></table></figure>

<p>在这里我们<code>c</code>和<code>d</code>都是在函数内部声明的，但是因为<code>c</code>使用了<code>var</code>，而<code>d</code>没有使用<code>var</code>声明，所以在外部能够使用<code>d</code>；也就是所谓的声明了一个<strong>全局变量</strong></p>
<hr>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>在理解了<strong>全局变量</strong>和<strong>局部变量</strong>之后，我们先写一个简单的闭包实例给大家看看：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myTest4</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = <span class="title function_">myTest4</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">func</span>());<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p>在这里我们是不是有点明白了呢：如果我们想用一个变量或者得到一个变量，但是我们又不想全局声明定义这个变量，到这的时候我们就可以通过闭包来调用函数内部的变量。</p>
<p>但是我们也应该知道闭包产生的值是一直保存在内存中的。这里通过一个例子给大家看看：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myTest5</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = <span class="title function_">myTest5</span>();</span><br><span class="line"><span class="title function_">func</span>();<span class="comment">//4</span></span><br><span class="line"><span class="title function_">func</span>();<span class="comment">//5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">func</span>());<span class="comment">//6  </span></span><br></pre></td></tr></table></figure>

<p>这个例子就是说调用一次，然后<code>i</code>的值就变了一次并且会一直被保存，然后下次调用的时候就是上次保存的值了。</p>
<h5 id="一些闭包实例"><a href="#一些闭包实例" class="headerlink" title="一些闭包实例:"></a>一些闭包实例:</h5><p><strong>&#x2F;* 例子1 *&#x2F;</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFn</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">innerFn</span>(<span class="params"></span>)&#123;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> innerFn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> inner = <span class="title function_">outerFn</span>();  <span class="comment">//每次外部函数执行的时候,都会开辟一块内存空间,外部函数的地址不同，都会重新创建一个新的地址</span></span><br><span class="line"><span class="title function_">inner</span>(); <span class="comment">//1</span></span><br><span class="line"><span class="title function_">inner</span>(); <span class="comment">//2</span></span><br><span class="line"><span class="title function_">inner</span>(); <span class="comment">//3</span></span><br><span class="line"><span class="keyword">var</span> inner2 = <span class="title function_">outerFn</span>();</span><br><span class="line"><span class="title function_">inner2</span>(); <span class="comment">//1</span></span><br><span class="line"><span class="title function_">inner2</span>(); <span class="comment">//2</span></span><br><span class="line"><span class="title function_">inner2</span>(); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p><strong>&#x2F;* 例子2 *&#x2F;</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">m1</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(++x);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">m1</span>()();   <span class="comment">//2</span></span><br><span class="line"><span class="title function_">m1</span>()();   <span class="comment">//2</span></span><br><span class="line"><span class="title function_">m1</span>()();   <span class="comment">//2</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> m2 = <span class="title function_">m1</span>();</span><br><span class="line"><span class="title function_">m2</span>();   <span class="comment">//2</span></span><br><span class="line"><span class="title function_">m2</span>();   <span class="comment">//3</span></span><br><span class="line"><span class="title function_">m2</span>();   <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p><strong>&#x2F;* 例子3 *&#x2F;</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;lis.<span class="property">length</span>;i++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">      lis[i].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;)(i);       <span class="comment">//事件处理函数中闭包的写法</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<hr>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6><h4 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h4><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE浏览器中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>一个简单的回收实例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myTest6</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">var</span> i = <span class="number">4</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> i++;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">var</span> func = <span class="title function_">myTest5</span>();</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">func</span>());<span class="comment">//4</span></span><br><span class="line"> func = <span class="literal">null</span>;<span class="comment">//n被回收</span></span><br><span class="line"> <span class="keyword">var</span> func = <span class="title function_">myTest5</span>();</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">func</span>());<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>闭包的缺点就是常驻内存，闭包会使变量始终保存在内存中，如果使用不当会增大内存使用量，造成内存泄露。</p>
</li>
<li><p>正常情况下外部函数是不能访问内部函数的变量的，但是可以利用闭包来实现对函数内部变量的访问。</p>
</li>
<li><p>一般函数执行完毕后，局部活动对象就被销毁，内存中仅仅保存全局作用域。但闭包的情况不同！</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>在React项目中应用TypeScript</title>
    <url>/2022/09/08/react-typescript/</url>
    <content><![CDATA[<h2 id="如何在React项目中应用说说如何在反应项目中应用TypeScript"><a href="#如何在React项目中应用说说如何在反应项目中应用TypeScript" class="headerlink" title="如何在React项目中应用说说如何在反应项目中应用TypeScript?"></a>如何在React项目中应用说说如何在反应项目中应用TypeScript?</h2><p><img src="https://static.vue-js.com/a98974e0-13bc-11ec-a752-75723a64e8f5.png"></p>
<h2 id="一、前言："><a href="#一、前言：" class="headerlink" title="一、前言："></a>一、前言：</h2><p>使用 <code>TypeScript</code> 编写 <code>React</code> 代码，除了需要 <code>TypeScript</code> 这个库之外，还需要安装 <code>@types/react</code>、<code>@types/react-dom</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i @types/react -s   || yarn add @types/react -s</span><br><span class="line">npm i @types/react-dom -s  ||  yarn add @types/react-dom -s</span><br></pre></td></tr></table></figure>

<p>至于上述使用 <code>@types</code> 的库的原因在于，目前非常多的 <code>JavaScript</code> 库并没有提供自己关于 <code>TypeScript</code> 的声明文件</p>
<p>所以，<code>ts</code> 并不知道这些库的类型以及对应导出的内容，这里 <code>@types</code> 实际就是社区中的 <code>DefinitelyTyped</code> 库，定义了目前市面上绝大多数的 <code>JavaScript</code> 库的声明</p>
<p>所以下载相关的 <code>JavaScript</code> 对应的 <code>@types</code> 声明时，就能够使用使用该库对应的类型定义</p>
<hr>
<span id="more"></span>

<h2 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h2><p>在编写 <code>React</code> 项目的时候，最常见的使用的组件就是：</p>
<ul>
<li>无状态组件</li>
<li>有状态组件</li>
<li>受控组件</li>
</ul>
<hr>
<h3 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件:"></a>无状态组件:</h3><p>主要作用是用于展示 <code>UI</code>，如果使用 <code>js</code> 声明，则如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;React&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Logo</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; logo, className, alt &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;logo&#125;</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span> <span class="attr">alt</span>=<span class="string">&#123;alt&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但这时候 <code>ts</code> 会出现报错提示，原因在于没有定义 <code>porps</code> 类型，这时候就可以使用 <code>interface</code> 接口去定义 <code>porps</code> 即可，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;React&quot;</span>;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IProps</span> &#123;</span><br><span class="line">  logo?: string;</span><br><span class="line">  className?: string;</span><br><span class="line">  alt?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Logo</span> = (<span class="params">props: IProps</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; logo, className, alt &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;logo&#125;</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span> <span class="attr">alt</span>=<span class="string">&#123;alt&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是我们都知道 <code>props</code> 里面存在 <code>children</code> 属性，我们不可能每个 <code>porps</code> 接口里面定义多一个 <code>children</code>，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">IProps</span> &#123;</span><br><span class="line">  logo?: string;</span><br><span class="line">  className?: string;</span><br><span class="line">  alt?: string;</span><br><span class="line">  children?: <span class="title class_">ReactNode</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更加规范的写法是使用 <code>React</code> 里面定义好的 <code>FC</code> 属性，里面已经定义好 <code>children</code> 类型，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Logo</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">IProps</span>&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; logo, className, alt &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;logo&#125;</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span> <span class="attr">alt</span>=<span class="string">&#123;alt&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="有状态组件"><a href="#有状态组件" class="headerlink" title="有状态组件:"></a>有状态组件:</h3><p>可以是一个类组件且存在 <code>props</code> 和 <code>state</code> 属性</p>
<p>如果使用 <code>TypeScript</code> 声明则如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;React&quot;</span>;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IProps</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: string;</span><br><span class="line">  size?: string;</span><br><span class="line">&#125;</span><br><span class="line">interface <span class="title class_">IState</span> &#123;</span><br><span class="line">  <span class="attr">count</span>: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&lt;<span class="title class_">IProps</span>, <span class="title class_">IState</span>&gt; &#123;</span><br><span class="line">  public state = &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  public <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述通过泛型对 <code>props</code>、<code>state</code> 进行类型定义，然后在使用的时候就可以在编译器中获取更好的智能提示</p>
<p>关于 <code>Component</code> 泛型类的定义，可以参考下 React 的类型定义文件 <code>node_modules/@types/React/index.d.ts</code>，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span>&lt;P, S&gt; &#123;</span><br><span class="line">  readonly <span class="attr">props</span>: <span class="title class_">Readonly</span>&lt;&#123; children?: <span class="title class_">ReactNode</span> &#125;&gt; &amp; <span class="title class_">Readonly</span>&lt;P&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="attr">state</span>: <span class="title class_">Readonly</span>&lt;S&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述可以看到，<code>state</code> 属性也定义了可读类型，目的是为了防止直接调用 <code>this.state</code> 更新状态</p>
<hr>
<h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件:"></a>受控组件:</h3><p>受控组件的特性在于元素的内容通过组件的状态 <code>state</code> 进行控制</p>
<p>由于组件内部的事件是合成事件，不等同于原生事件，</p>
<p>例如一个 <code>input</code> 组件修改内部的状态，常见的定义的时候如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">private <span class="title function_">updateValue</span>(<span class="params">e: React.ChangeEvent&lt;HTMLInputElement&gt;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">itemText</span>: e.<span class="property">target</span>.<span class="property">value</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>上述只是简单的在 <code>React</code> 项目使用 <code>TypeScript</code>，但在编写 <code>React</code> 项目的时候，还存在 <code>hooks</code>、默认参数、以及 <code>store</code> 等等……</p>
<hr>
<blockquote>
<p>基于hexo搭建的一个博客:<a href="https://nanxiangscholar.github.io/">https://nanxiangscholar.github.io/</a></p>
<p>欢迎访问!</p>
</blockquote>
]]></content>
      <categories>
        <category>typescript</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>在Vue项目中应用TypeScript</title>
    <url>/2022/09/12/vue-typescript/</url>
    <content><![CDATA[<h1 id="如何在Vue项目中应用TypeScript？"><a href="#如何在Vue项目中应用TypeScript？" class="headerlink" title="如何在Vue项目中应用TypeScript？"></a>如何在Vue项目中应用TypeScript？</h1><p><img src="https://static.vue-js.com/cc658c10-1565-11ec-8e64-91fdec0f05a1.png"></p>
<hr>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在<code>VUE</code>项目中应用<code>typescript</code>，我们需要引入一个库<code>vue-property-decorator</code>，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># npm 下载</span><br><span class="line">npm i vue-property-decorator -s</span><br><span class="line"># yarn 下载</span><br><span class="line">yarn add vue-property-decorator -s</span><br></pre></td></tr></table></figure>

<p>其是基于<code>vue-class-component</code>库而来，这个库<code>vue</code>官方推出的一个支持使用<code>class</code>方式来开发<code>vue</code>单文件组件的库</p>
<p>主要的功能如下：</p>
<ul>
<li>methods 可以直接声明为类的成员方法</li>
<li>计算属性可以被声明为类的属性访问器</li>
<li>初始化的 data 可以被声明为类属性</li>
<li>data、render 以及所有的 Vue 生命周期钩子可以直接作为类的成员方法</li>
<li>所有其他属性，需要放在装饰器中</li>
</ul>
<span id="more"></span>

<h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><p><code>vue-property-decorator</code> 主要提供了多个装饰器和一个函数:</p>
<ul>
<li>@Prop</li>
<li>@PropSync</li>
<li>@Model</li>
<li>@Watch</li>
<li>@Provide</li>
<li>@Inject</li>
<li>@ProvideReactive</li>
<li>@InjectReactive</li>
<li>@Emit</li>
<li>@Ref</li>
<li>@Component (由 vue-class-component 提供)</li>
<li>Mixins (由 vue-class-component 提供)</li>
</ul>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p><code>Component</code>装饰器它注明了此类为一个<code>Vue</code>组件，因此即使没有设置选项也不能省略</p>
<p>如果需要定义比如 <code>name</code>、<code>components</code>、<code>filters</code>、<code>directives</code>以及自定义属性，就可以在<code>Component</code>装饰器中定义，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Component</span>,<span class="title class_">Vue</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;componentA,componentB&#125; <span class="keyword">from</span> <span class="string">&#x27;@/components&#x27;</span>;</span><br><span class="line"></span><br><span class="line"> @<span class="title class_">Component</span>(&#123;</span><br><span class="line">    <span class="attr">components</span>:&#123;</span><br><span class="line">        componentA,</span><br><span class="line">        componentB,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">directives</span>: &#123;</span><br><span class="line">        <span class="attr">focus</span>: &#123;</span><br><span class="line">            <span class="comment">// 指令的定义</span></span><br><span class="line">            <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">                el.<span class="title function_">focus</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">YourCompoent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="computed、data、methods"><a href="#computed、data、methods" class="headerlink" title="computed、data、methods"></a>computed、data、methods</h3><p>这里取消了组件的data和methods属性，以往data返回对象中的属性、methods中的方法需要直接定义在Class中，当做类的属性和方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">HelloDecorator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">    <span class="attr">count</span>: number = <span class="number">123</span> <span class="comment">// 类属性相当于以前的 data</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">add</span>(): number &#123; <span class="comment">// 类方法就是以前的方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取计算属性</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">total</span>(): number &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置计算属性</span></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">total</span>(<span class="params">param:number</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span> = param</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="props"><a href="#props" class="headerlink" title="@props"></a>@props</h3><p>组件接收属性的装饰器，如下使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Component</span>,<span class="title class_">Vue</span>,<span class="title class_">Prop</span>&#125; <span class="keyword">from</span> vue-property-decorator;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">YourComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">    @<span class="title class_">Prop</span>(<span class="title class_">String</span>)</span><br><span class="line">    <span class="attr">propA</span>:string;</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Prop</span>([<span class="title class_">String</span>,<span class="title class_">Number</span>])</span><br><span class="line">    <span class="attr">propB</span>:string|number;</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Prop</span>(&#123;</span><br><span class="line">     <span class="attr">type</span>: <span class="title class_">String</span>, <span class="comment">// type: [String , Number]</span></span><br><span class="line">     <span class="attr">default</span>: <span class="string">&#x27;default value&#x27;</span>, <span class="comment">// 一般为String或Number</span></span><br><span class="line">      <span class="comment">//如果是对象或数组的话。默认值从一个工厂函数中返回</span></span><br><span class="line">      <span class="comment">// defatult: () =&gt; &#123;</span></span><br><span class="line">      <span class="comment">//     return [&#x27;a&#x27;,&#x27;b&#x27;]</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">     <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">     <span class="attr">validator</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">          <span class="string">&#x27;InProcess&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Settled&#x27;</span></span><br><span class="line">        ].<span class="title function_">indexOf</span>(value) !== -<span class="number">1</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="attr">propC</span>:string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="watch"><a href="#watch" class="headerlink" title="@watch"></a>@watch</h3><p>实际就是<code>Vue</code>中的监听器，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Vue</span>, <span class="title class_">Component</span>, <span class="title class_">Watch</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">YourComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  @<span class="title class_">Watch</span>(<span class="string">&#x27;child&#x27;</span>)</span><br><span class="line">  <span class="title function_">onChildChanged</span>(<span class="params">val: string, oldVal: string</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title class_">Watch</span>(<span class="string">&#x27;person&#x27;</span>, &#123; <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="attr">deep</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="title function_">onPersonChanged1</span>(<span class="params">val: Person, oldVal: Person</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title class_">Watch</span>(<span class="string">&#x27;person&#x27;</span>)</span><br><span class="line">  <span class="title function_">onPersonChanged2</span>(<span class="params">val: Person, oldVal: Person</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="emit"><a href="#emit" class="headerlink" title="@emit"></a>@emit</h3><p><code>vue-property-decorator</code> 提供的 <code>@Emit</code> 装饰器就是代替<code>Vue</code>中的事件的触发<code>$emit</code>，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Vue</span>, <span class="title class_">Component</span>, <span class="title class_">Emit</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="line">    @<span class="title class_">Component</span>(&#123;&#125;)</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Some</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span>&#123;</span><br><span class="line">        <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.$on(<span class="string">&#x27;emit-todo&#x27;</span>, <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">emitTodo</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        @<span class="title class_">Emit</span>()</span><br><span class="line">        <span class="title function_">emitTodo</span>(<span class="params">n: string</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="三-、总结"><a href="#三-、总结" class="headerlink" title="三 、总结"></a>三 、总结</h2><p>可以看到上述<code>typescript</code>版本的<code>vue class</code>的语法与平时<code>javascript</code>版本使用起来还是有很大的不同，多处用到<code>class</code>与装饰器，但实际上本质是一致的，只有不断编写才会得心应手。</p>
<hr>
<blockquote>
<p>基于hexo搭建的一个博客:<a href="https://nanxiangscholar.github.io/">https://nanxiangscholar.github.io/</a></p>
<p>欢迎访问!</p>
</blockquote>
]]></content>
      <categories>
        <category>typescript</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>手写setTimeout和setInterval</title>
    <url>/2022/09/15/setTimeout-setIterval/</url>
    <content><![CDATA[<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>写代码之前需要知道<em>setTimeout</em>实现原理：本质上就是在给定的时间向任务队列添加回调函数，并执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mySetTimeout</span>(<span class="params">...rest</span>)&#123;</span><br><span class="line">      <span class="comment">// 1.得到调用setTimeoutMy函数时的时间戳</span></span><br><span class="line">      <span class="keyword">let</span> start =<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">      <span class="comment">// 2.得到回调函数结束的时间</span></span><br><span class="line">      <span class="keyword">let</span> end = start+ rest[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 3. 监听事件变化，当事件到达指定的结束时间时，结束回调函数</span></span><br><span class="line">      <span class="keyword">let</span> timer =<span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">let</span> time =<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">          <span class="keyword">if</span>(time&gt;=end)&#123;</span><br><span class="line">             <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">             rest[<span class="number">0</span>](rest[<span class="number">2</span>]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,<span class="number">17</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;同步执行----&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mySetTimeout</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;,<span class="number">1000</span>,<span class="string">&#x27;执行结果&#x27;</span>)</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">  同步执行---- # 从这里可以看出<span class="built_in">setTimeout</span>本身执行是同步的，执行的回调函数是异步的</span><br><span class="line">  执行结果  # 输出结果，是在<span class="number">1</span>秒之后输出</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<hr>
<h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><p>写代码之前需要知道<em>setInterval</em>实现原理：本质上就是每隔一定的时间向任务队列添加回调函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mySetInterval</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rest数组接受三个参数:</span></span><br><span class="line"><span class="comment">     *  1)回调函数               rest[0]</span></span><br><span class="line"><span class="comment">     *  2)执行回调函数所需的时间  rest[1]</span></span><br><span class="line"><span class="comment">     *  3)操作元素               rest[2]  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">interval</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rest[<span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2:利用setTimeout在给定的时间，就调用回调函数的原理,使用递归思想，自己调用自己.</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(interval, rest[<span class="number">1</span>])</span><br><span class="line">            rest[<span class="number">0</span>]();</span><br><span class="line">            rest[<span class="number">2</span>]--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 3：条件不符合，退出函数</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1:利用setTimeout在mySetInterval被调用时异步调用一次。</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(interval, rest[<span class="number">1</span>]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;同步执行----&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">mySetInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">-----------</span><br><span class="line">结果：</span><br><span class="line">	同步执行----  # 从这里可以看出setIterval本身执行是同步的，执行的回调函数是异步的</span><br><span class="line">	<span class="number">1</span></span><br><span class="line">	<span class="number">1</span></span><br><span class="line">	<span class="number">1</span></span><br><span class="line">	<span class="number">1</span></span><br><span class="line">	<span class="number">1</span></span><br><span class="line">	<span class="number">1</span></span><br><span class="line">	<span class="number">1</span></span><br><span class="line">	<span class="number">1</span>  # 输出<span class="number">8</span>次<span class="number">1</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论:"></a>结论:</h3><blockquote>
<p>setTimeout:</p>
<blockquote>
<p>1.得到调用setTimeoutMy函数时的时间戳；</p>
<p>2.得到回调函数结束的时间；</p>
<p>3.监听事件变化，当事件到达指定的结束时间时，结束回调函数。</p>
</blockquote>
</blockquote>
<blockquote>
<p>setIterval:</p>
<blockquote>
<p>1:利用setTimeout在mySetInterval被调用时异步调用一次;</p>
<p>2:利用setTimeout在给定的时间，就调用回调函数的原理,使用递归思想，自己调用自己。</p>
</blockquote>
</blockquote>
<h6 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h6><p><em>setTimeout</em>和<em>setIterval</em>本身执行是同步的，执行的回调函数是异步的。</p>
]]></content>
  </entry>
  <entry>
    <title>手写instanceof</title>
    <url>/2022/09/17/instanceof/</url>
    <content><![CDATA[<h2 id="手写instanceof"><a href="#手写instanceof" class="headerlink" title="手写instanceof"></a>手写instanceof</h2><p>首先写之前要先理解一下<strong>instanceof</strong>的实现原理:</p>
<ul>
<li><strong>instanceof</strong> 主要的实现原理就是只要右边变量的<strong>prototype</strong>在左边变量的原型链上即可(<em><strong>也就是说左边的变量能在原型链上找到左边变量的prototype)</strong></em></li>
</ul>
<hr>
<span id="more"></span>

<p>了解原理之后开始看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 声明myInstanceof函数,接受两个参数left, right</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">myInstanceOf</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">        <span class="comment">// 1:声明rightval变量，来得到传入的对象的原型对象</span></span><br><span class="line">        <span class="keyword">let</span> rightVal = right.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">        <span class="comment">// 2:声明leftval变量，来得到传入的对象的原型对象</span></span><br><span class="line">        <span class="keyword">let</span> leftVal = left.<span class="property">__proto__</span></span><br><span class="line">        <span class="comment">// 3：循环遍历左边变量的原型链，查找，如果找不到就到一直循环到父类型或祖类型</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftVal === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (leftVal === rightVal) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            leftVal = leftVal.<span class="property">__proto__</span> <span class="comment">// 获取祖类型的__proto__</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例:</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"> <span class="keyword">let</span> test = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceOf</span>(test, <span class="title class_">Test</span>));</span><br><span class="line"></span><br><span class="line"> ------------------</span><br><span class="line"> 结果：</span><br><span class="line"> <span class="literal">true</span>  </span><br></pre></td></tr></table></figure>



<h5 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h5><blockquote>
<p>instanceof在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false.</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>web常见的攻击方式</title>
    <url>/2022/09/23/web-attack/</url>
    <content><![CDATA[<h1 id="web常见的攻击方式有哪些？如何防御？"><a href="#web常见的攻击方式有哪些？如何防御？" class="headerlink" title="web常见的攻击方式有哪些？如何防御？"></a>web常见的攻击方式有哪些？如何防御？</h1><br>

<h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>Web攻击（WebAttack）是针对用户上网行为或网站服务器等设备进行攻击的行为</p>
<p>首先常见的Web攻击方式有</p>
<ul>
<li>XSS (Cross Site Scripting) 跨站脚本攻击</li>
<li>CSRF（Cross-site request forgery）跨站请求伪造</li>
<li>SQL注入攻击</li>
</ul>
<span id="more"></span>

<h2 id="二、XSS"><a href="#二、XSS" class="headerlink" title="二、XSS"></a>二、XSS</h2><p>XSS，跨站脚本攻击，允许攻击者将恶意代码植入到提供给其它用户使用的页面中</p>
<p><code>XSS</code>涉及到三方，即攻击者、客户端与<code>Web</code>应用</p>
<p><code>XSS</code>的攻击目标是为了盗取存储在客户端的<code>cookie</code>或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互</p>
<p>举个例子：</p>
<p>一个搜索页面，根据<code>url</code>参数决定关键词的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;&lt;%= getParameter(&quot;</span>keyword<span class="string">&quot;) %&gt;&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  您搜索的关键词是：&lt;%= getParameter(&quot;keyword&quot;) %&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>这里看似并没有问题，但是如果不按套路出牌呢？</p>
<p>用户输入<code>&quot;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code>，拼接到 HTML 中返回给浏览器。形成了如下的 HTML：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;&quot;</span>&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;XSS&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;button&gt;搜索&lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">  您搜索的关键词是：&quot;</span>&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;XSS&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>浏览器无法分辨出 <code>&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code> 是恶意代码，因而将其执行，试想一下，如果是获取<code>cookie</code>发送对黑客服务器呢？</p>
<p>根据攻击的来源，<code>XSS</code>攻击可以分成：</p>
<ul>
<li>存储型</li>
<li>反射型</li>
<li>DOM 型</li>
</ul>
<h3 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h3><p>存储型 XSS 的攻击步骤：</p>
<ol>
<li>攻击者将恶意代码提交到目标网站的数据库中</li>
<li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li>
</ol>
<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等</p>
<h3 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h3><p>反射型 XSS 的攻击步骤：</p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码</li>
<li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li>
</ol>
<p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</p>
<p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。</p>
<p>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</p>
<p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见</p>
<h3 id="DOM-型-XSS"><a href="#DOM-型-XSS" class="headerlink" title="DOM 型 XSS"></a>DOM 型 XSS</h3><p>DOM 型 XSS 的攻击步骤：</p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码</li>
<li>用户打开带有恶意代码的 URL</li>
<li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li>
</ol>
<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞</p>
<h3 id="XSS的预防"><a href="#XSS的预防" class="headerlink" title="XSS的预防"></a>XSS的预防</h3><p>通过前面介绍，看到<code>XSS</code>攻击的两大要素：</p>
<ul>
<li>攻击者提交而恶意代码</li>
<li>浏览器执行恶意代码</li>
</ul>
<p>针对第一个要素，我们在用户输入的过程中，过滤掉用户输入的恶劣代码，然后提交给后端，但是如果攻击者绕开前端请求，直接构造请求就不能预防了</p>
<p>而如果在后端写入数据库前，对输入进行过滤，然后把内容给前端，但是这个内容在不同地方就会有不同显示</p>
<p>例如：</p>
<p>一个正常的用户输入了 <code>5 &lt; 7</code> 这个内容，在写入数据库前，被转义，变成了 <code>5 &lt; 7</code></p>
<p>在客户端中，一旦经过了 <code>escapeHTML()</code>，客户端显示的内容就变成了乱码( <code>5 &lt; 7</code> )</p>
<p>在前端中，不同的位置所需的编码也不同。</p>
<ul>
<li>当 <code>5 &lt; 7</code> 作为 HTML 拼接页面时，可以正常显示：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div title=<span class="string">&quot;comment&quot;</span>&gt;<span class="number">5</span> &amp;lt; <span class="number">7</span>&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>当 <code>5 &lt; 7</code> 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等</li>
</ul>
<p>可以看到，过滤并非可靠的，下面就要通过防止浏览器执行恶意代码：</p>
<p>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等</p>
<p>如果用 <code>Vue/React</code> 技术栈，并且不使用 <code>v-html</code>&#x2F;<code>dangerouslySetInnerHTML</code> 功能，就在前端 <code>render</code> 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患</p>
<p>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 链接内包含恶意代码 --&gt;</span><br><span class="line">&lt; a href=<span class="string">&quot; &quot;</span>&gt;<span class="number">1</span>&lt;/ a&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// setTimeout()/setInterval() 中调用恶意代码</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// location 调用恶意代码</span></span><br><span class="line">location.<span class="property">href</span> = <span class="string">&#x27;UNTRUSTED&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eval() 中调用恶意代码</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="三、CSRF"><a href="#三、CSRF" class="headerlink" title="三、CSRF"></a>三、CSRF</h2><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求</p>
<p>利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目</p>
<p>一个典型的CSRF攻击有着如下的流程：</p>
<ul>
<li>受害者登录a.com，并保留了登录凭证（Cookie）</li>
<li>攻击者引诱受害者访问了b.com</li>
<li>b.com 向 a.com 发送了一个请求：a.com&#x2F;act&#x3D;xx。浏览器会默认携带a.com的Cookie</li>
<li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求</li>
<li>a.com以受害者的名义执行了act&#x3D;xx</li>
<li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作</li>
</ul>
<p><code>csrf</code>可以通过<code>get</code>请求，即通过访问<code>img</code>的页面后，浏览器自动访问目标地址，发送请求</p>
<p>同样，也可以设置一个自动提交的表单发送<code>post</code>请求，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;https://nanxiangscholar.github.io/&quot;</span> method=<span class="variable constant_">POST</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xiaoming&quot;</span> /&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;for&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">submit</span>(); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> </span><br></pre></td></tr></table></figure>

<p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次<code>POST</code>操作</p>
<p>还有一种为使用<code>a</code>标签的，需要用户点击链接才会触发</p>
<p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">## 测试网络地址</span><br><span class="line">&lt; a href=<span class="string">&quot;https://nanxiangscholar.github.io/&quot;</span> taget=<span class="string">&quot;_blank&quot;</span>&gt;</span><br><span class="line">    重磅消息！！</span><br><span class="line">&lt;a/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="CSRF的特点"><a href="#CSRF的特点" class="headerlink" title="CSRF的特点"></a>CSRF的特点</h3><ul>
<li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生</li>
<li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据</li>
<li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”</li>
<li>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪</li>
</ul>
<h3 id="CSRF的预防"><a href="#CSRF的预防" class="headerlink" title="CSRF的预防"></a>CSRF的预防</h3><p>CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性</p>
<p>防止<code>csrf</code>常用方案如下：</p>
<ul>
<li>阻止不明外域的访问<ul>
<li>同源检测</li>
<li>Samesite Cookie</li>
</ul>
</li>
<li>提交时要求附加本域才能获取的信息<ul>
<li>CSRF Token</li>
<li>双重Cookie验证</li>
</ul>
</li>
</ul>
<p>这里主要讲讲<code>token</code>这种形式，流程如下：</p>
<ul>
<li>用户打开页面的时候，服务器需要给这个用户生成一个Token</li>
<li>对于GET请求，Token将附在请求地址之后。对于 POST 请求来说，要在 form 的最后加上</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性</li>
</ul>
<h2 id="四、SQL注入"><a href="#四、SQL注入" class="headerlink" title="四、SQL注入"></a>四、SQL注入</h2><p>Sql 注入攻击，是通过将恶意的 <code>Sql</code>查询或添加语句插入到应用的输入参数中，再在后台 <code>Sql</code>服务器上解析执行进行的攻击:</p>
<p><img src="D:\桌面\ead52fa0-8d1d-11eb-85f6-6fac77c0c9b3.png"></p>
<p>流程如下所示：</p>
<ul>
<li>找出SQL漏洞的注入点</li>
<li>判断数据库的类型以及版本</li>
<li>猜解用户名和密码</li>
<li>利用工具查找Web后台管理入口</li>
<li>入侵和破坏</li>
</ul>
<p>预防方式如下：</p>
<ul>
<li>严格检查输入变量的类型和格式</li>
<li>过滤和转义特殊字符</li>
<li>对访问数据库的Web应用程序采用Web应用防火墙</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>TypeScript快速入门</title>
    <url>/2022/09/26/TypeScript/</url>
    <content><![CDATA[<h1 id="TypeScript快速入门"><a href="#TypeScript快速入门" class="headerlink" title="TypeScript快速入门"></a>TypeScript快速入门</h1><hr>
<br>

<h2 id="1、TypeScript简介"><a href="#1、TypeScript简介" class="headerlink" title="1、TypeScript简介"></a>1、TypeScript简介</h2><ul>
<li><p>ts是js的超集，存在类型的脚本语言;</p>
</li>
<li><p>继承了js的所有编程类型，js代码可在ts环境很好的运行;</p>
</li>
<li><p>新增类型注解和类型推断</p>
</li>
<li><p>拥有丰富的class扩展功能</p>
</li>
<li><p>强大的类型系统，拥有静态类型检查能力</p>
</li>
</ul>
 <br>

<span id="more"></span>
<h2 id="2、基本类型"><a href="#2、基本类型" class="headerlink" title="2、基本类型"></a>2、基本类型</h2><ul>
<li><p>类型声明</p>
<ul>
<li><p>类型声明是TS非常重要的一个特点</p>
</li>
<li><p>通过类型声明可以指定TS中变量（参数、形参）的类型</p>
</li>
<li><p>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错</p>
</li>
<li><p>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值</p>
</li>
<li><p>语法：</p>
<ul>
<li><p>&#96;&#96;&#96;typescript<br>let 变量: 类型;</p>
<p>let 变量: 类型 &#x3D; 值;</p>
<p>function fn(参数: 类型, 参数: 类型): 类型{<br>…<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 自动类型判断</span><br><span class="line"></span><br><span class="line">  - TS拥有自动的类型判断机制</span><br><span class="line">  - 当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型</span><br><span class="line">  - 所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明</span><br><span class="line"></span><br><span class="line">- 类型：</span><br><span class="line"></span><br><span class="line">  |  类型   |       例子        |              描述              |</span><br><span class="line">  | :-----: | :---------------: | :----------------------------: |</span><br><span class="line">  | number  |    1, -33, 2.5    |            任意数字            |</span><br><span class="line">  | string  | &#x27;hi&#x27;, &quot;hi&quot;, `hi`  |           任意字符串           |</span><br><span class="line">  | boolean |    true、false    |       布尔值true或false        |</span><br><span class="line">  | 字面量  |      其本身       |  限制变量的值就是该字面量的值  |</span><br><span class="line">  |   any   |         *         |            任意类型            |</span><br><span class="line">  | unknown |         *         |         类型安全的any          |</span><br><span class="line">  |  void   | 空值（undefined） |     没有值（或undefined）      |</span><br><span class="line">  |  never  |      没有值       |          不能是任何值          |</span><br><span class="line">  | object  |  &#123;name:&#x27;孙悟空&#x27;&#125;  |          任意的JS对象          |</span><br><span class="line">  |  array  |      [1,2,3]      |           任意JS数组           |</span><br><span class="line">  |  tuple  |       [4,5]       | 元组，TS新增类型，固定长度数组 |</span><br><span class="line">  |  enum   |    enum&#123;A, B&#125;     |       枚举，TS中新增类型       |</span><br><span class="line"></span><br><span class="line">- number(数字型)</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let decimal: number = 6;</span><br><span class="line">    let hex: number = 0xf00d;</span><br><span class="line">    let binary: number = 0b1010;</span><br><span class="line">    let octal: number = 0o744;</span><br><span class="line">    let big: bigint = 100n;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>boolean(布尔型)</p>
<ul>
<li>&#96;&#96;&#96;typescript<br>let isDone: boolean &#x3D; false;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- string(字符串型)</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let color: string = &quot;blue&quot;;</span><br><span class="line">    color = &#x27;red&#x27;;</span><br><span class="line">    </span><br><span class="line">    let fullName: string = `Bob Bobbington`;</span><br><span class="line">    let age: number = 37;</span><br><span class="line">    let sentence: string = `Hello, my name is $&#123;fullName&#125;.</span><br><span class="line">    </span><br><span class="line">    I&#x27;ll be $&#123;age + 1&#125; years old next month.`;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>字面量</p>
<ul>
<li><p>也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围</p>
</li>
<li><p>&#96;&#96;&#96;typescript<br>let color: ‘red’ | ‘blue’ | ‘black’;<br>let num: 1 | 2 | 3 | 4 | 5;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- any(任意型)</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let d: any = 4;</span><br><span class="line">    d = &#x27;hello&#x27;;</span><br><span class="line">    d = true;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>unknown(类型安全的any)；</p>
<ul>
<li><p><strong>注意</strong>:unknown和any都是TS中的顶级类型，但主要区别在于：<strong>使用any相当于彻底放弃了类型检查</strong>，而unknown类型相较于any更加严格，在执行大多数操作之前，会进行某种形式的检查(不允许访问属性，不允许赋值给其他有明确类型的变量)。</p>
</li>
<li><p>&#96;&#96;&#96;typescript<br>let notSure: unknown &#x3D; 4;<br>notSure &#x3D; ‘hello’;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- void</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let unusable: void = undefined;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>never</p>
<ul>
<li>&#96;&#96;&#96;typescript<br>function error(message: string): never {<br>  throw new Error(message);<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- object(不怎么用)</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let obj: object = &#123;&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>array</p>
<ul>
<li>&#96;&#96;&#96;typescript<br>let list: number[] &#x3D; [1, 2, 3];<br>let list: Array<number> &#x3D; [1, 2, 3];<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- tuple</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let x: [string, number];</span><br><span class="line">    x = [&quot;hello&quot;, 10]; </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>enum</p>
<ul>
<li><p>&#96;&#96;&#96;typescript<br>enum Color {<br>  Red,<br>  Green,<br>  Blue,<br>}<br>let c: Color &#x3D; Color.Green;</p>
<p>enum Color {<br>  Red &#x3D; 1,<br>  Green,<br>  Blue,<br>}<br>let c: Color &#x3D; Color.Green;</p>
<p>enum Color {<br>  Red &#x3D; 1,<br>  Green &#x3D; 2,<br>  Blue &#x3D; 4,<br>}<br>let c: Color &#x3D; Color.Green;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 类型断言</span><br><span class="line"></span><br><span class="line">  - 类型断言就相当于在编译阶段进行类型转换；</span><br><span class="line"></span><br><span class="line">  - 有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</span><br><span class="line"></span><br><span class="line">    - 第一种</span><br><span class="line">  </span><br><span class="line">      - ```typescript</span><br><span class="line">        let someValue: unknown = &quot;this is a string&quot;;</span><br><span class="line">        let strLength: number = (someValue as string).length;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第二种</p>
<ul>
<li>&#96;&#96;&#96;typescript<br>let someValue: unknown &#x3D; “this is a string”;<br>let strLength: number &#x3D; (<string>someValue).length;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">## 3、编译选项</span><br><span class="line"></span><br><span class="line">- 自动编译文件</span><br><span class="line"></span><br><span class="line">  - 编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```powershell</span><br><span class="line">      tsc xxx.ts -w</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>自动编译整个项目</p>
<ul>
<li><p>如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。</p>
</li>
<li><p>但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json</p>
</li>
<li><p>tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译</p>
</li>
<li><p>配置选项：</p>
<ul>
<li><p>include</p>
<ul>
<li><p>定义希望被编译文件所在的目录</p>
</li>
<li><p>默认值：[“**&#x2F;*“]</p>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="json">&quot;include&quot;:[&quot;src/**/*&quot;, &quot;tests/**/*&quot;]
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 上述示例中，所有src目录和tests目录下的文件都会被编译</span><br><span class="line"></span><br><span class="line">- exclude</span><br><span class="line"></span><br><span class="line">  - 定义需要排除在外的目录</span><br><span class="line"></span><br><span class="line">  - 默认值：[&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;]</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;exclude&quot;: [&quot;./src/hello/**/*&quot;]</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>上述示例中，src下hello目录下的文件都不会被编译</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>extends</p>
<ul>
<li><p>定义被继承的配置文件</p>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="json">&quot;extends&quot;: &quot;./configs/base&quot;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息</span><br><span class="line"></span><br><span class="line">- files</span><br><span class="line"></span><br><span class="line">  - 指定被编译文件的列表，只有需要编译的文件少时才会用到</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;files&quot;: [</span><br><span class="line">          &quot;core.ts&quot;,</span><br><span class="line">          &quot;sys.ts&quot;,</span><br><span class="line">          &quot;types.ts&quot;,</span><br><span class="line">          &quot;scanner.ts&quot;,</span><br><span class="line">          &quot;parser.ts&quot;,</span><br><span class="line">          &quot;utilities.ts&quot;,</span><br><span class="line">          &quot;binder.ts&quot;,</span><br><span class="line">          &quot;checker.ts&quot;,</span><br><span class="line">          &quot;tsc.ts&quot;</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>列表中的文件都会被TS编译器所编译</p>
</li>
</ul>
</li>
<li><p>compilerOptions</p>
<ul>
<li><p>编译选项是配置文件中非常重要也比较复杂的配置选项</p>
</li>
<li><p>在compilerOptions中包含多个子选项，用来完成对编译的配置</p>
<ul>
<li><p>项目选项</p>
<ul>
<li><p>target</p>
<ul>
<li><p>设置ts代码编译的目标版本</p>
</li>
<li><p>可选值：</p>
<ul>
<li>ES3（默认）、ES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li>&#96;&#96;&#96;json<br>“compilerOptions”: {<br>“target”: “ES6”<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码</span><br><span class="line"></span><br><span class="line">- lib</span><br><span class="line"></span><br><span class="line">  - 指定代码运行时所包含的库（宿主环境）</span><br><span class="line"></span><br><span class="line">  - 可选值：</span><br><span class="line"></span><br><span class="line">    - ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;compilerOptions&quot;: &#123;</span><br><span class="line">          &quot;target&quot;: &quot;ES6&quot;,</span><br><span class="line">          &quot;lib&quot;: [&quot;ES6&quot;, &quot;DOM&quot;],</span><br><span class="line">          &quot;outDir&quot;: &quot;dist&quot;,</span><br><span class="line">          &quot;outFile&quot;: &quot;dist/aa.js&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>module</p>
<ul>
<li><p>设置编译后代码使用的模块化系统</p>
</li>
<li><p>可选值：</p>
<ul>
<li>CommonJS、UMD、AMD、System、ES2020、ESNext、None</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="typescript">&quot;compilerOptions&quot;: &#123;
    &quot;module&quot;: &quot;CommonJS&quot;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- outDir</span><br><span class="line"></span><br><span class="line">  - 编译后文件的所在目录</span><br><span class="line"></span><br><span class="line">  - 默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;compilerOptions&quot;: &#123;</span><br><span class="line">          &quot;outDir&quot;: &quot;dist&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>设置后编译后的js文件将会生成到dist目录</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>outFile</p>
<ul>
<li><p>将所有的文件编译为一个js文件</p>
</li>
<li><p>默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中</p>
</li>
<li><p>示例：</p>
<ul>
<li>&#96;&#96;&#96;json<br>“compilerOptions”: {<br>“outFile”: “dist&#x2F;app.js”<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- rootDir</span><br><span class="line"></span><br><span class="line">  - 指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;compilerOptions&quot;: &#123;</span><br><span class="line">          &quot;rootDir&quot;: &quot;./src&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>allowJs</p>
<ul>
<li>是否对js文件编译</li>
</ul>
</li>
<li><p>checkJs</p>
<ul>
<li><p>是否对js文件进行检查</p>
</li>
<li><p>示例：</p>
<ul>
<li>&#96;&#96;&#96;json<br>“compilerOptions”: {<br>“allowJs”: true,<br>“checkJs”: true<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">            - removeComments</span><br><span class="line"></span><br><span class="line">              - 是否删除注释</span><br><span class="line">              - 默认值：false</span><br><span class="line"></span><br><span class="line">            - noEmit</span><br><span class="line"></span><br><span class="line">              - 不对代码进行编译</span><br><span class="line">              - 默认值：false</span><br><span class="line"></span><br><span class="line">            - sourceMap</span><br><span class="line"></span><br><span class="line">              - 是否生成sourceMap</span><br><span class="line">              - 默认值：false</span><br><span class="line"></span><br><span class="line">              </span><br><span class="line"></span><br><span class="line">          - 严格检查</span><br><span class="line"></span><br><span class="line">            - strict</span><br><span class="line">              - 启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查</span><br><span class="line">            - alwaysStrict</span><br><span class="line">              - 总是以严格模式对代码进行编译</span><br><span class="line">            - noImplicitAny</span><br><span class="line">              - 禁止隐式的any类型</span><br><span class="line">            - noImplicitThis</span><br><span class="line">              - 禁止类型不明确的this</span><br><span class="line">            - strictBindCallApply</span><br><span class="line">              - 严格检查bind、call和apply的参数列表</span><br><span class="line">            - strictFunctionTypes</span><br><span class="line">              - 严格检查函数的类型</span><br><span class="line">            - strictNullChecks</span><br><span class="line">              - 严格的空值检查</span><br><span class="line">            - strictPropertyInitialization</span><br><span class="line">              - 严格检查属性是否初始化</span><br><span class="line"></span><br><span class="line">          - 额外检查</span><br><span class="line"></span><br><span class="line">            - noFallthroughCasesInSwitch</span><br><span class="line">              - 检查switch语句包含正确的break</span><br><span class="line">            - noImplicitReturns</span><br><span class="line">              - 检查函数没有隐式的返回值</span><br><span class="line">            - noUnusedLocals</span><br><span class="line">              - 检查未使用的局部变量</span><br><span class="line">            - noUnusedParameters</span><br><span class="line">              - 检查未使用的参数</span><br><span class="line"></span><br><span class="line">          - 高级</span><br><span class="line"></span><br><span class="line">            - allowUnreachableCode</span><br><span class="line">              - 检查不可达代码</span><br><span class="line">              - 可选值：</span><br><span class="line">                - true，忽略不可达代码</span><br><span class="line">                - false，不可达代码将引起错误</span><br><span class="line">            - noEmitOnError</span><br><span class="line">              - 有错误的情况下不进行编译</span><br><span class="line">              - 默认值：false</span><br><span class="line"></span><br><span class="line">## 4、webpack</span><br><span class="line"></span><br><span class="line">- 通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。</span><br><span class="line"></span><br><span class="line">- 步骤：</span><br><span class="line"></span><br><span class="line">  1. 初始化项目</span><br><span class="line"></span><br><span class="line">     - 进入项目根目录，执行命令 ``` npm init -y```</span><br><span class="line">       - 主要作用：创建package.json文件</span><br><span class="line"></span><br><span class="line">  2. 下载构建工具</span><br><span class="line"></span><br><span class="line">     - ```npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin```</span><br><span class="line">       - 共安装了7个包</span><br><span class="line">         - webpack</span><br><span class="line">           - 构建工具webpack</span><br><span class="line">         - webpack-cli</span><br><span class="line">           - webpack的命令行工具</span><br><span class="line">         - webpack-dev-server</span><br><span class="line">           - webpack的开发服务器</span><br><span class="line">         - typescript</span><br><span class="line">           - ts编译器</span><br><span class="line">         - ts-loader</span><br><span class="line">           - ts加载器，用于在webpack中编译ts文件</span><br><span class="line">         - html-webpack-plugin</span><br><span class="line">           - webpack中html插件，用来自动创建html文件</span><br><span class="line">         - clean-webpack-plugin</span><br><span class="line">           - webpack中的清除插件，每次构建都会先清除目录</span><br><span class="line"></span><br><span class="line">  3. 根目录下创建webpack的配置文件webpack.config.js</span><br><span class="line"></span><br><span class="line">     - ```javascript</span><br><span class="line">       const path = require(&quot;path&quot;);</span><br><span class="line">       const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);</span><br><span class="line">       const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);</span><br><span class="line">       </span><br><span class="line">       module.exports = &#123;</span><br><span class="line">           optimization:&#123;</span><br><span class="line">               minimize: false // 关闭代码压缩，可选</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           entry: &quot;./src/index.ts&quot;,</span><br><span class="line">           </span><br><span class="line">           devtool: &quot;inline-source-map&quot;,</span><br><span class="line">           </span><br><span class="line">           devServer: &#123;</span><br><span class="line">               contentBase: &#x27;./dist&#x27;</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           output: &#123;</span><br><span class="line">               path: path.resolve(__dirname, &quot;dist&quot;),</span><br><span class="line">               filename: &quot;bundle.js&quot;,</span><br><span class="line">               environment: &#123;</span><br><span class="line">                   arrowFunction: false // 关闭webpack的箭头函数，可选</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           resolve: &#123;</span><br><span class="line">               extensions: [&quot;.ts&quot;, &quot;.js&quot;]</span><br><span class="line">           &#125;,</span><br><span class="line">           </span><br><span class="line">           module: &#123;</span><br><span class="line">               rules: [</span><br><span class="line">                   &#123;</span><br><span class="line">                       test: /\.ts$/,</span><br><span class="line">                       use: &#123;</span><br><span class="line">                          loader: &quot;ts-loader&quot;     </span><br><span class="line">                       &#125;,</span><br><span class="line">                       exclude: /node_modules/</span><br><span class="line">                   &#125;</span><br><span class="line">               ]</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           plugins: [</span><br><span class="line">               new CleanWebpackPlugin(),</span><br><span class="line">               new HtmlWebpackPlugin(&#123;</span><br><span class="line">                   title:&#x27;TS测试&#x27;</span><br><span class="line">               &#125;),</span><br><span class="line">           ]</span><br><span class="line">       </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li><p>根目录下创建tsconfig.json，配置可以根据自己需要</p>
<ul>
<li>&#96;&#96;&#96;json<br>{<br>“compilerOptions”: {<br>    “target”: “ES2015”,<br>    “module”: “ES2015”,<br>    “strict”: true<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. 修改package.json添加如下配置</span><br><span class="line"></span><br><span class="line">   - ```json</span><br><span class="line">     &#123;</span><br><span class="line">       ...略...</span><br><span class="line">       &quot;scripts&quot;: &#123;</span><br><span class="line">         &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">         &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">         &quot;start&quot;: &quot;webpack serve --open chrome.exe&quot;</span><br><span class="line">       &#125;,</span><br><span class="line">       ...略...</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在src下创建ts文件，并在并命令行执行<code>npm run build</code>对代码进行编译，或者执行<code>npm start</code>来启动开发服务器</p>
</li>
</ol>
</li>
</ul>
]]></content>
  </entry>
</search>
